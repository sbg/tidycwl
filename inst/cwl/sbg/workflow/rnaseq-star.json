{
  "$namespaces": {
    "sbg": "https://sevenbridges.com"
  },
  "hints": [
    {
      "class": "sbg:AWSInstanceType",
      "value": "c4.8xlarge;ebs-gp2;500"
    },
    {
      "class": "sbg:GoogleInstanceType",
      "value": "n1-standard-32;pd-ssd;4096"
    },
    {
      "class": "sbg:AlibabaCloudInstanceType",
      "value": "ecs.c5.8xlarge;cloud_ssd;600"
    }
  ],
  "label": "RNA-seq alignment - STAR 2.5.4b",
  "sbg:categories": [
    "Alignment",
    "RNA"
  ],
  "sbg:canvas_x": 158,
  "description": "This workflow performs the first step of RNA-seq analysis - alignment to a reference genome and transcriptome. \n\n**STAR** (Spliced Transcripts Alignment to a Reference), an ultrafast RNA-seq aligner, is used in this workflow. **STAR** is capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. **STAR** employs an RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\nThe main idea behind this workflow is to generate aligned BAM files (in genome and transcriptome coordinates) from RNA-seq data, which can later be used in further RNA studies, like gene expression analysis for example. \n\nThe important notes about the workflow are: \n\n- The workflow consists of two steps: **STAR Genome Generate**, which generates the necessary index files for the alignment procedure, and **STAR** itself, which does the alignment.\n- The main input to the workflow are **Reads** (`--readFilesIn`) in FASTQ format (single end or paired end), or unaligned BAM format.\n- A **Reference or index** file also needs to be provided. If the index archive is already generated for the desired reference, it can be provided instead of the reference in order to skip indexing and save computation time. Otherwise, a reference FASTA file is required here.\n- If a FASTA file is provided as an input, a **Splice junctions GTF file** (`--sjdbGTFfile`) should also be provided. It\u2019s generally a good idea to always provide a GTF file to the inputs, if you want to get the **Transcriptome aligned reads** and **Reads per gene** outputs. \n- The main output of this workflow is the **Aligned reads** output in coordinate-sorted BAM format. The **Transcriptome aligned reads** BAM file is also produced by default. \n- Gene counts are also outputted by default on the **Reads per gene** output. \n- STAR can detect chimeric transcripts, but the parameter **Min segment length** (`--chimSegmentMin`) in *Chimeric Alignments*  category must be adjusted to a desired minimum chimeric segment length (12 is a good value, as recommended by the **STAR-Fusion** wiki, which is set by default). This output can later be used in **STAR-Fusion** for further fusion analysis. \n- If you want to use **STAR** results as an input to an RNA-seq differential expression analysis (using the **Cufflinks** app), set the parameter **Strand field flag** (`--outSAMstrandField`) to **intronMotif**.\n- Unmapped reads are outputted by default, both in FASTQ format on the **Unmapped reads** output, and within the main out BAM file on the **Aligned reads** and **Transcriptome aligned reads** outputs. \n- A basic **Two-pass mode** is also turned on during the alignment step, which means that all the first pass junctions will be inserted into the genome indices for the second pass. \n\n###Common issues###\n- For paired-end read files, it is important to properly set the **Paired-end** metadata field on your read files.\n- For FASTQ reads in multi-file format (i.e. two FASTQ files for paired-end 1 and two FASTQ files for paired-end2), the proper metadata needs to be set (the following hierarchy is valid: **Sample ID/Library ID/Platform Unit ID/File Segment Number**).\n- The GTF and FASTA files need to have compatible transcript IDs and chromosome names.\n\n### Changes Introduced by Seven Bridges\n\n- All output files will be prefixed by the input sample ID (inferred from the **Sample ID** metadata if existent, of from filename otherwise), unless the **Output file name prefix** option is explicitly specified.\n- **Unmapped reads** in FASTQ format are by default unsorted by read ID. This can induce problems if these files are used in a subsequent analysis (i.e. downstream alignment). This is changed in this workflow - unmapped reads are by default sorted by read ID. This option can be turned off to decrease workflow runtime by a small margin, if unmapped reads are not of further interest. The suffix for the **Unmapped reads** output can be controlled by the **Unmapped output file names** options (the default is *Unmapped*).\n- The workflow can accept uncompressed FASTQ files, as well as GZ and BZ2 compressed FASTQ files, without the user having to specify anything. Also, if unaligned BAM files are used as inputs, the single-end/paired-end flag (SE/PE) needn't be specified - it will be inferred automatically using a built-in **Samtools** script. \n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs for a couple of samples with different file sizes, with the following workflow options in mind - indexing is not performed, unmapped reads are sorted by read id, output BAM is sorted by coordinate and basic two pass mode is turned on:\n\n\n\n\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost |  Instance (AWS) |\n|:---------------:|:-----------:|:----------:|:----------:|:-----------:|:--------:|:-----:|:----------:|\n|     RNA-Seq     |  2 x 230 MB |     Yes    |     1M     |     101     |   18min   | $0.40 | c4.8xlarge |\n|     RNA-Seq     |  2 x 4.5 GB |     Yes    |     20M     |     101     |   30min   | $0.60 | c4.8xlarge |\n|     RNA-Seq     | 2 x 17.4 GB |     Yes    |     76M    |     101     |   64min  | $1.20 | c4.8xlarge |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### API Python Implementation\nThe workflow's draft task can also be submitted via the **API**. In order to learn how to get your **Authentication token** and **API endpoint** for corresponding platform visit our [documentation](https://github.com/sbg/sevenbridges-python#authentication-and-configuration).\n\n```python\nfrom sevenbridges import Api\n\n# Enter api credentials\nauthentication_token, api_endpoint = \"enter_your_token\", \"enter_api_endpoint\"\napi = Api(token=authentication_token, url=api_endpoint)\n\n# Get project_id/workflow_id from your address bar. Example: https://igor.sbgenomics.com/u/your_username/project/workflow\nproject_id, workflow_id = \"your_username/project\", \"your_username/project/workflow\"\n\n# Get file names from files in your project. File names below are just as an example.\ninputs = {\n        'reads': list(api.files.query(project=project_id, names=['sample_pe1.fq', 'sample_pe2.fq'])),\n        'sjdbGTFfile': list(api.files.query(project=project_id, names=['gtf_file.gtf'])),\n        'reference_or_index': list(api.files.query(project=project_id, names=['reference_fasta_file.fa']))\n        }\n\n# Run the task\ntask = api.tasks.create(name='RNA-seq alignment - STAR 2.5.4b - API Example', project=project_id, app=workflow_id, inputs=inputs, run=True)\n```\nInstructions for installing and configuring the API Python client, are provided on [github](https://github.com/sbg/sevenbridges-python#installation). For more information about using the API Python client, consult [sevenbridges-python documentation](http://sevenbridges-python.readthedocs.io/en/latest/). **More examples** are available [here](https://github.com/sbg/okAPI).\n\nAdditionally, [API R](https://github.com/sbg/sevenbridges-r) and [API Java](https://github.com/sbg/sevenbridges-java) clients are available. To learn more about using these API clients please refer to the [API R client documentation](https://sbg.github.io/sevenbridges-r/), and [API Java client documentation](https://docs.sevenbridges.com/docs/java-library-quickstart).\n\n### References\n\n[1] [STAR paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)",
  "sbg:license": "GNU General Public License v3.0 only",
  "outputs": [
    {
      "source": [
        "#STAR.unmapped_reads"
      ],
      "sbg:x": 729.8212576238807,
      "sbg:fileTypes": "FASTQ",
      "label": "Unmapped reads",
      "required": false,
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "sbg:includeInPorts": true,
      "id": "#unmapped_reads",
      "sbg:y": 181.96426064296259,
      "description": "Unmapped reads in FASTQ format."
    },
    {
      "source": [
        "#STAR.aligned_reads"
      ],
      "sbg:x": 727.9762057983685,
      "sbg:fileTypes": "SAM, BAM",
      "label": "Aligned reads",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#aligned_reads",
      "sbg:y": 466.42858758616086,
      "description": "Aligned sequence in SAM/BAM format."
    },
    {
      "source": [
        "#STAR.transcriptome_aligned_reads"
      ],
      "sbg:x": 1080.6665468480794,
      "sbg:fileTypes": "BAM",
      "label": "Transcriptome aligned reads",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#transcriptome_aligned_reads",
      "sbg:y": 86.58333168758271,
      "description": "Alignments translated into transcript coordinates."
    },
    {
      "source": [
        "#STAR.chimeric_alignments"
      ],
      "sbg:x": 1092.583376417558,
      "sbg:fileTypes": "SAM",
      "label": "Chimeric alignments",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#chimeric_alignments",
      "sbg:y": 524.9166468348755,
      "description": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs."
    },
    {
      "source": [
        "#STAR.chimeric_junctions"
      ],
      "sbg:x": 1260.4164733389925,
      "sbg:fileTypes": "JUNCTION",
      "label": "Chimeric junctions",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#chimeric_junctions",
      "sbg:y": 465.0833205680043,
      "description": "Chimeric junctions file. If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output."
    },
    {
      "source": [
        "#STAR.splice_junctions"
      ],
      "sbg:x": 1250.6663921011695,
      "sbg:fileTypes": "TAB",
      "label": "Splice junctions",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#splice_junctions",
      "sbg:y": 165.8333094716061,
      "description": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported."
    },
    {
      "source": [
        "#STAR.reads_per_gene"
      ],
      "sbg:x": 1397.7498524222037,
      "sbg:fileTypes": "TAB",
      "label": "Reads per gene",
      "required": false,
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#reads_per_gene",
      "sbg:y": 252.41666652427753,
      "description": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene."
    },
    {
      "source": [
        "#STAR.log_files"
      ],
      "sbg:x": 1405.083226339679,
      "sbg:fileTypes": "OUT",
      "label": "Log files",
      "required": false,
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "sbg:includeInPorts": true,
      "id": "#log_files",
      "sbg:y": 396.3333287371524,
      "description": "Log files produced during alignment."
    }
  ],
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Copy of uros_sipetic/star-workflow-2-5-3a-demo/star-workflow-2-5-3a/32"
    },
    {
      "sbg:revision": 1,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Initial set-up"
    },
    {
      "sbg:revision": 2,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Bump to 2.5.4b"
    },
    {
      "sbg:revision": 3,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Update label name"
    },
    {
      "sbg:revision": 4,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Set chimSegmentMin to 12 default."
    },
    {
      "sbg:revision": 5,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Expose outSAMstrandField"
    },
    {
      "sbg:revision": 6,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "set 2pass mode to basic as default"
    },
    {
      "sbg:revision": 7,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949980,
      "sbg:revisionNotes": "Update description."
    },
    {
      "sbg:revision": 8,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Update description."
    },
    {
      "sbg:revision": 9,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Update description"
    },
    {
      "sbg:revision": 10,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Add Benchmarking table"
    },
    {
      "sbg:revision": 11,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "TwoPass Mode - exposed parameter not showing bux fix - part1"
    },
    {
      "sbg:revision": 12,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "TwoPass Mode - exposed parameter not showing bux fix - part2"
    },
    {
      "sbg:revision": 13,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Update STAR & STAR Genome Generate with newest descriptions."
    },
    {
      "sbg:revision": 14,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Small description update"
    },
    {
      "sbg:revision": 15,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Update description per the doc-team revision notes"
    },
    {
      "sbg:revision": 16,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1522949981,
      "sbg:revisionNotes": "Set suggested files (grch37)"
    },
    {
      "sbg:revision": 17,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1523982018,
      "sbg:revisionNotes": "Update STAR to include BAM index, remove intermediate genome output, as it was mostly unnecessary"
    },
    {
      "sbg:revision": 18,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1545142561,
      "sbg:revisionNotes": "Add ALI instance hint"
    },
    {
      "sbg:revision": 19,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1551106985,
      "sbg:revisionNotes": "Changes made to reads JS expression in order to handle multiple samples on input."
    }
  ],
  "sbg:canvas_y": 20,
  "sbg:image_url": "https://igor.sbgenomics.com/ns/brood/images/admin/sbg-public-data/rna-seq-alignment-star-2-5-4b/19.png",
  "sbg:expand_workflow": false,
  "inputs": [
    {
      "sbg:x": 119.40479247721515,
      "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
      "sbg:suggestedValue": [
        {
          "path": "5772b6c4507c1752674486cd",
          "name": "Homo_sapiens.GRCh37.75.gtf",
          "class": "File"
        }
      ],
      "label": "Splice junctions GTF file",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "sbg:includeInPorts": true,
      "id": "#sjdbGTFfile",
      "sbg:y": 197.50006363127184,
      "description": "Gene annotation file in GTF/GFF format. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\"."
    },
    {
      "sbg:x": 121.30959554418948,
      "sbg:fileTypes": "FASTA, FA, FNA, TAR",
      "sbg:suggestedValue": {
        "path": "5ac62cee4f0ce70dc8f79481",
        "name": "human_g1k_v37_decoy.phiX174.Homo_sapiens.GRCh37.75.star-2.5.4b-index-archive.tar",
        "class": "File"
      },
      "label": "Reference or index",
      "type": [
        "File"
      ],
      "sbg:includeInPorts": true,
      "id": "#reference_or_index",
      "sbg:y": 458.3335245119269,
      "description": "Reference sequence to which to align the reads, or a TAR bundle containing already generated indices."
    },
    {
      "sbg:x": 123.45241026556775,
      "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
      "label": "Reads",
      "type": [
        {
          "items": "File",
          "type": "array"
        }
      ],
      "sbg:includeInPorts": true,
      "id": "#reads",
      "sbg:y": 332.1428964989536,
      "description": "Read files, either in FASTQ or SAM/BAM formats."
    },
    {
      "label": "\"Overhang\" length",
      "sbg:category": "Splice junctions db parameters",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "100",
      "id": "#sjdbOverhang",
      "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used."
    },
    {
      "sbg:toolDefaultValue": "transcript_id",
      "label": "Exons' parents name",
      "required": false,
      "type": [
        "null",
        "string"
      ],
      "sbg:category": "Splice junctions db parameters",
      "id": "#sjdbGTFtagExonParentTranscript",
      "description": "Tag name to be used as exons transcript-parents."
    },
    {
      "sbg:toolDefaultValue": "gene_id",
      "label": "Gene name",
      "required": false,
      "type": [
        "null",
        "string"
      ],
      "sbg:category": "Splice junctions db parameters",
      "id": "#sjdbGTFtagExonParentGene",
      "description": "Tag name to be used as exons gene-parents."
    },
    {
      "label": "Limit Genome Generate RAM",
      "sbg:category": "Run parameters",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "30",
      "id": "#limitGenomeGenerateRAM",
      "description": "Upper RAM limit for genome generation, in GB."
    },
    {
      "label": "Bins size",
      "sbg:category": "Genome generation parameters",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "18",
      "id": "#genomeChrBinNbits",
      "description": "Set log2(chrBin), where chrBin is the size (bits) of the bins for genome storage: each chromosome will occupy an integer number of bins. If you are using a genome with a large (>5,000) number of chrosomes/scaffolds, you may need to reduce this number to reduce RAM consumption. The following scaling is recomended: genomeChrBinNbits = min(18, log2(GenomeLength/NumberOfReferences)). For example, for 3 gigaBase genome with 100,000 chromosomes/scaffolds, this is equal to 15.",
      "sbg:stageInput": null
    },
    {
      "sbg:suggestedValue": "Fastx",
      "label": "Output unmapped reads",
      "sbg:category": "Output",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--outReadsUnmapped"
      },
      "type": [
        "null",
        {
          "name": "outReadsUnmapped",
          "symbols": [
            "None",
            "Fastx"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "None",
      "id": "#outReadsUnmapped",
      "description": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2."
    },
    {
      "sbg:suggestedValue": null,
      "label": "Output format",
      "sbg:category": "Output",
      "inputBinding": {
        "valueFrom": {
          "class": "Expression",
          "script": "{\n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  if (SAM_type && SORT_type) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type)\n    }\n  } else if (SAM_type && SORT_type==null) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" Unsorted\")\n    }\n  } else {\n    if (SORT_type) {\n      return \"--outSAMtype \".concat(\"BAM\", \" \", SORT_type)\n    } else {\n      return \"--outSAMtype \".concat(\"BAM\", \" Unsorted\")\n    }\n  }\n}",
          "engine": "#cwl-js-engine"
        },
        "sbg:cmdInclude": true,
        "separate": true
      },
      "type": [
        "null",
        {
          "name": "outSAMtype",
          "symbols": [
            "SAM",
            "BAM"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "BAM",
      "id": "#outSAMtype",
      "description": "Format of output alignments."
    },
    {
      "sbg:suggestedValue": "SortedByCoordinate",
      "label": "Output sorting type",
      "sbg:category": "Output",
      "type": [
        "null",
        {
          "name": "outSortingType",
          "symbols": [
            "Unsorted",
            "SortedByCoordinate"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "Unsorted",
      "id": "#outSortingType",
      "description": "Type of output sorting."
    },
    {
      "label": "Strand field flag",
      "sbg:category": "Output",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--outSAMstrandField"
      },
      "type": [
        "null",
        {
          "name": "outSAMstrandField",
          "symbols": [
            "None",
            "intronMotif"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "None",
      "id": "#outSAMstrandField",
      "description": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out."
    },
    {
      "sbg:suggestedValue": "Within KeepPairs",
      "label": "Write unmapped in SAM",
      "sbg:category": "Output",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--outSAMunmapped"
      },
      "type": [
        "null",
        {
          "name": "outSAMunmapped",
          "symbols": [
            "None",
            "Within",
            "Within KeepPairs"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "None",
      "id": "#outSAMunmapped",
      "description": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam)."
    },
    {
      "label": "Sorting in SAM",
      "sbg:category": "Output",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--outSAMorder"
      },
      "type": [
        "null",
        {
          "name": "outSAMorder",
          "symbols": [
            "Paired",
            "PairedKeepInputOrder"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "Paired",
      "id": "#outSAMorder",
      "description": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files."
    },
    {
      "sbg:suggestedValue": 12,
      "label": "Min segment length",
      "sbg:category": "Chimeric Alignments",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--chimSegmentMin"
      },
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "0",
      "id": "#chimSegmentMin",
      "description": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0)."
    },
    {
      "sbg:suggestedValue": "TranscriptomeSAM GeneCounts",
      "label": "Quantification mode",
      "sbg:category": "Quantification of Annotations",
      "type": [
        "null",
        {
          "name": "quantMode",
          "symbols": [
            "TranscriptomeSAM",
            "GeneCounts",
            "TranscriptomeSAM GeneCounts"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "-",
      "id": "#quantMode",
      "description": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping."
    },
    {
      "label": "Reads to process in 1st step",
      "sbg:category": "2-pass mapping",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "-1",
      "id": "#twopass1readsN",
      "description": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number (or default -1) to map all reads in the first step (int>0)."
    },
    {
      "sbg:suggestedValue": "Basic",
      "label": "Two-pass mode",
      "sbg:category": "2-pass mapping",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--twopassMode"
      },
      "type": [
        "null",
        {
          "name": "twopassMode",
          "symbols": [
            "None",
            "Basic"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "None",
      "id": "#twopassMode",
      "description": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly."
    },
    {
      "label": "Chimeric output type",
      "sbg:category": "Chimeric Alignments",
      "type": [
        "null",
        {
          "name": "chimOutType",
          "symbols": [
            "SeparateSAMold",
            "Within SoftClip",
            "Within HardClip"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "SeparateSAMold",
      "id": "#chimOutType",
      "description": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; Within: output into main aligned SAM/BAM files (can be hard-clipping or soft-clipping in the CIGAR for supplemental chimeric alignments)."
    },
    {
      "label": "Prohibit alignment type",
      "sbg:category": "Quantification of Annotations",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--quantTranscriptomeBan"
      },
      "type": [
        "null",
        {
          "name": "quantTranscriptomeBan",
          "symbols": [
            "IndelSoftclipSingleend",
            "Singleend"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "IndelSoftclipSingleend",
      "id": "#quantTranscriptomeBan",
      "description": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments."
    },
    {
      "label": "Limit BAM sorting memory",
      "sbg:category": "Limits",
      "inputBinding": {
        "valueFrom": {
          "class": "Expression",
          "script": "{\n  return $job.inputs.limitBAMsortRAM ? $job.inputs.limitBAMsortRAM : 57000000000\n}\n",
          "engine": "#cwl-js-engine"
        },
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--limitBAMsortRAM"
      },
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "57000000000",
      "id": "#limitBAMsortRAM",
      "description": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size."
    },
    {
      "label": "Chimeric filter",
      "sbg:category": "Chimeric Alignments",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "separate": true,
        "prefix": "--chimFilter"
      },
      "type": [
        "null",
        {
          "name": "chimFilter",
          "symbols": [
            "banGenomicN",
            "None"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "banGenomicN",
      "id": "#chimFilter",
      "description": "Different filters for chimeric alignments None no filtering banGenomicN Ns are not allowed in the genome sequence around the chimeric junction."
    },
    {
      "label": "Unmapped output file names",
      "sbg:category": "Output",
      "type": [
        "null",
        "string"
      ],
      "sbg:toolDefaultValue": "\"Unmapped.out\"",
      "id": "#unmappedOutputName",
      "description": "Names of the unmapped output files."
    },
    {
      "label": "No read groups",
      "sbg:category": "Read group",
      "type": [
        "null",
        "boolean"
      ],
      "sbg:toolDefaultValue": "Off",
      "id": "#no_read_groups",
      "description": "If this boolean argument is specified, no read groups will be set in the resulting BAM header."
    },
    {
      "sbg:suggestedValue": true,
      "label": "Sort unmapped reads",
      "sbg:category": "Output",
      "type": [
        "null",
        "boolean"
      ],
      "sbg:toolDefaultValue": "Off",
      "id": "#sortUnmappedReads",
      "description": "Unmapped reads are, by default, unsorted. If you want to sort them by read ID, please specify this option, though keep in mind that this can increase STAR run time."
    },
    {
      "label": "Number of threads",
      "sbg:category": "Run parameters",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "32",
      "id": "#runThreadN",
      "description": "Number of threads to use."
    },
    {
      "label": "Output file name prefix",
      "sbg:category": "Output",
      "type": [
        "null",
        "string"
      ],
      "sbg:toolDefaultValue": "sample_id",
      "id": "#outFileNamePrefix",
      "description": "Prefix to be added to all output files."
    },
    {
      "sbg:suggestedValue": null,
      "label": "BAM remove duplicates type",
      "sbg:category": "BAM processing",
      "inputBinding": {
        "valueFrom": {
          "class": "Expression",
          "script": "{\n  var x = $job.inputs.reads\n  if (x.length==2 && $job.inputs.bamRemoveDuplicatesType) {\n    return \"--bamRemoveDuplicatesType \" + $job.inputs.bamRemoveDuplicatesType\n  } else {\n    return \"\"\n  }\n  \n}",
          "engine": "#cwl-js-engine"
        },
        "sbg:cmdInclude": true,
        "separate": true
      },
      "type": [
        "null",
        {
          "name": "bamRemoveDuplicatesType",
          "symbols": [
            "UniqueIdentical",
            "UniqueIdenticalNotMulti"
          ],
          "type": "enum"
        }
      ],
      "sbg:toolDefaultValue": "Off",
      "id": "#bamRemoveDuplicatesType",
      "description": "Mark duplicates in the BAM file. For now, only works with paired-end alignments. UniqueIdentical: mark all mutlimappers and duplicate unique mappers. The coordinates, FLAG, CIGAR must be identical. UniqueIdenticalNotMulti: mark duplicate unique mappers but not multimappers."
    },
    {
      "label": "BAM remove duplicates mate2 bases",
      "sbg:category": "BAM processing",
      "inputBinding": {
        "valueFrom": {
          "class": "Expression",
          "script": "{\n  var x = $job.inputs.reads\n  if (x.length==2 && $job.inputs.bamRemoveDuplicatesMate2basesN && $job.inputs.bamRemoveDuplicatesType) {\n    return \"--bamRemoveDuplicatesMate2basesN \" + $job.inputs.bamRemoveDuplicatesMate2basesN\n  } else {\n    return \"\"\n  }\n}",
          "engine": "#cwl-js-engine"
        },
        "sbg:cmdInclude": true,
        "separate": true
      },
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "0",
      "id": "#bamRemoveDuplicatesMate2basesN",
      "description": "Number of bases from the 5' end of mate 2 to use in collapsing (e.g. for RAMPAGE)."
    },
    {
      "label": "\"Overhang\" length",
      "sbg:category": "Splice junctions database",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "100",
      "id": "#sjdbOverhang_1",
      "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used."
    }
  ],
  "steps": [
    {
      "sbg:x": 399.2857017167019,
      "inputs": [
        {
          "id": "#STAR_Genome_Generate.sjdbScore"
        },
        {
          "source": [
            "#sjdbOverhang"
          ],
          "id": "#STAR_Genome_Generate.sjdbOverhang"
        },
        {
          "source": [
            "#sjdbGTFtagExonParentTranscript"
          ],
          "id": "#STAR_Genome_Generate.sjdbGTFtagExonParentTranscript"
        },
        {
          "source": [
            "#sjdbGTFtagExonParentGene"
          ],
          "id": "#STAR_Genome_Generate.sjdbGTFtagExonParentGene"
        },
        {
          "source": [
            "#sjdbGTFfile"
          ],
          "id": "#STAR_Genome_Generate.sjdbGTFfile"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR_Genome_Generate.sjdbFileChrStartEnd"
        },
        {
          "id": "#STAR_Genome_Generate.runThreadN"
        },
        {
          "source": [
            "#reference_or_index"
          ],
          "id": "#STAR_Genome_Generate.reference_or_index"
        },
        {
          "source": [
            "#limitGenomeGenerateRAM"
          ],
          "id": "#STAR_Genome_Generate.limitGenomeGenerateRAM"
        },
        {
          "id": "#STAR_Genome_Generate.genomeSuffixLengthMax"
        },
        {
          "id": "#STAR_Genome_Generate.genomeSAsparseD"
        },
        {
          "id": "#STAR_Genome_Generate.genomeSAindexNbases"
        },
        {
          "source": [
            "#genomeChrBinNbits"
          ],
          "id": "#STAR_Genome_Generate.genomeChrBinNbits"
        }
      ],
      "outputs": [
        {
          "id": "#STAR_Genome_Generate.genome"
        }
      ],
      "run": {
        "sbg:project": "uros_sipetic/star-2-5-4b-demo",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:revisionNotes": "Fix typo in description.",
        "outputs": [
          {
            "sbg:fileTypes": "TAR",
            "label": "Genome Files",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reference_or_index",
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var str1 = [].concat($job.inputs.reference_or_index)[0].path.split('/')\n  var str2 = str1[str1.length-1]\n  var str3 = str2.split('.')\n  var str4 = \"\"\n  for (i=0; i<str3.length-1; i++) {\n    if (i<str3.length-2) { \n    str4 = str4 + str3[i] + \".\"\n    }\n    else {\n      str4 = str4 + str3[i]\n    }\n  }\n  var tmp = str3.pop()\n  if (tmp.toLowerCase()=='fa' || tmp.toLowerCase()=='fasta') {\n    return str4\n  } else if (tmp.toLowerCase()=='tar') {\n    return [].concat($job.inputs.reference_or_index)[0].metadata.reference_genome\n  }\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "id": "#genome",
            "description": "Genome files comprise binary genome sequence, suffix arrays, text chromosome names/lengths, splice junctions coordinates, and transcripts/genes information."
          }
        ],
        "sbg:projectName": "STAR 2.5.4b - Demo",
        "x": 399.2857017167019,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "2.5.4b",
        "sbg:sbgMaintained": false,
        "sbg:createdOn": 1519136405,
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var x = $job.inputs.reference_or_index.path.split('/').pop()\n  var y = x.split('.').pop()\n  var z = $job.inputs.runThreadN ? $job.inputs.runThreadN : 32\n  if (y == 'fa' || y == 'fasta' || y == 'FA' || y == \"FASTA\") {\n    return \"mkdir genomeDir && STAR --runMode genomeGenerate --genomeDir ./genomeDir --runThreadN \" + z\n  } else if (y == 'tar' || y == 'TAR') {\n    return \"echo 'Tar bundle provided, skipping indexing.' \"\n  }\n}\n",
            "engine": "#cwl-js-engine"
          }
        ],
        "successCodes": [],
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "mkdir genomeDir && STAR --runMode genomeGenerate --genomeDir ./genomeDir --runThreadN 5 --genomeFastaFiles /sbgenomics/test-data/chr20.fa  && tar -vcf chr20.chr20.star-2.5.4b-index-archive.tar ./genomeDir",
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 5
          },
          "inputs": {
            "sjdbGTFtagExonParentTranscript": "sjdbGTFtagExonParentTranscript",
            "genomeSuffixLengthMax": 10,
            "genomeChrBinNbits": 5,
            "runThreadN": 5,
            "sjdbOverhang": 0,
            "sjdbGTFfeatureExon": "sjdbGTFfeatureExon",
            "reference_or_index": {
              "path": "/sbgenomics/test-data/chr20.fa",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "genomeSAsparseD": 0,
            "sjdbScore": 0,
            "sjdbGTFfile": [
              {
                "path": "/demo/test-files/chr20.txt",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "sjdbGTFchrPrefix": "sjdbGTFchrPrefix",
            "limitGenomeGenerateRAM": null,
            "sjdbFileChrStartEnd": [
              {
                "path": "/path/to/sjdbFileChrStartEnd-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/sjdbFileChrStartEnd-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "sjdbGTFtagExonParentGene": "sjdbGTFtagExonParentGene",
            "genomeSAindexNbases": 0
          }
        },
        "description": "**STAR Genome Generate** produces the necessary index files for successful **STAR** alignment, from an input FASTA and GTF files.  \n\n**STAR** (Spliced Transcripts Alignment to a Reference), an ultrafast RNA-seq aligner, is capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. **STAR** employs an RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\n**STAR Genome Generate** is a tool that generates genome index files. One set of files should be generated per each FASTA/GTF combination. Once produced, these files could be used as long as FASTA/GTF combination stays the same. Also, **STAR Genome Generate** which produced these files and **STAR** aligner using them must be of the same toolkit version.\n\n* If the indexes for a desired FASTA/GTF pair have already been generated, make sure to supply the resulting TAR bundle to the tool input if you are using this tool in a workflow in order to skip unnecessary indexing and speed up the whole workflow process.\n* If you are providing a GFF3 file (which are usually downloaded from **NCBI's RefSeq database**) and wish to use **STAR** results for further downstream analysis, a good idea would be to set the **Exon parent name** (`--sjdbGTFtagExonParentTranscript`) option to **Parent**.\n* If you wish to run **STAR** in **multiple samples two-pass mode**, you need to provide the resulting **splice junction** outputs from **STAR** to the **List of annotated junctions** (`--sjdbFileChrStartEnd`) input of **STAR Genome Generate**, and generate the index archive with these, instead of supplying the GTF file [2]. \n\n###Common issues###\n\n* If the reference genome used has a bit number of contig sequences (>5000), a suggestion is to set the **Bins size** (`--genomeChrBinNbits`) parameter to the value of min(18, log2(GenomeLength/NumberOfReferences)). \n* If the reference genome used is a rather small genome, a suggestion is to set the **Pre-indexing string length** (`--genomeSAindexNbases`) parameter to the value of min(14, log2(GenomeLength)/2 - 1). \n* If **STAR Genome Generates** for some reason fails because of insufficient RAM problem, the **Limit Genome Generate RAM** (`--limitGenomeGenerateRAM`) parameter can be increased to make the RAM demands, though since the default value is 60GB, this should only be happening with extremely large reference files (for example, 30GB is enough for the human reference genome). \n* The GTF and FASTA files need to have compatible transcript IDs and chromosome names.\n\n### Changes Introduced by Seven Bridges\n\n* The directory containing the index files will be outputted as a TAR bundle (the **Genome files** output). This bundle can then be provided to the **STAR** aligner, which will automatically take care of untarring it and preparing it to run successfully without further issues. \n\n### Performance Benchmarking\n\nSince **STAR Genome Generate** is run with a FASTA/GTF combination, the runtime of this tool will be pretty much constant across a number of different genomes. For the human reference genome, the tool is expected to finish in around 30 minutes, costing around $0.75 on the c4.8xlarge AWS instance. \n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n\n[1] [STAR paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)\n[2] [STAR manual](http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf)",
        "y": 428.4672820687532,
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1519136405,
            "sbg:revisionNotes": "Copy of uros_sipetic/star-2-5-3a-demo/star-genome-generate-2-5-3-a/9",
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1519140704,
            "sbg:revisionNotes": "Initial set-up",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1521211219,
            "sbg:revisionNotes": "Update description",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1521211673,
            "sbg:revisionNotes": "Update description (add manual to references)",
            "sbg:revision": 3
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1521213165,
            "sbg:revisionNotes": "Update description.",
            "sbg:revision": 4
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1521460183,
            "sbg:revisionNotes": "Fix typo in description.",
            "sbg:revision": 5
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/uros_sipetic/star:2.5.4b",
            "dockerImageId": ""
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n  return $job.inputs.runThreadN ? $job.inputs.runThreadN : 32\n}",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "class": "sbg:MemRequirement",
            "value": {
              "class": "Expression",
              "script": "{\n  return $job.inputs.limitGenomeGenerateRAM ? $job.inputs.limitGenomeGenerateRAM*1000 : 60000\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var tmp1 = [].concat($job.inputs.reference_or_index)[0].path.split('/').pop()\n  if ($job.inputs.sjdbGTFfile) {\n    var tmp2 = [].concat($job.inputs.sjdbGTFfile)[0].path.split('/').pop()\n  } else if ($job.inputs.sjdbFileChrStartEnd){\n    var tmp2 = [].concat($job.inputs.sjdbFileChrStartEnd)[0].path.split('/').pop()\n  } else {\n    var tmp2 = \"\"\n  }\n  \n  var str1 = tmp1.split('.')\n  var x1 = \"\"\n  for (i=0; i<str1.length-1; i++) {\n    if (i<str1.length-2) { \n    x1 = x1 + str1[i] + \".\"\n    }\n    else {\n      x1 = x1 + str1[i]\n    }\n  }\n  \n  var str2 = tmp2.split('.')\n  var x2 = \"\"\n  for (i=0; i<str2.length-1; i++) {\n    if (i<str2.length-2) { \n    x2 = x2 + str2[i] + \".\"\n    }\n    else {\n      x2 = x2 + str2[i] + \".\"\n    }\n  }\n  var tmp3 = $job.inputs.reference_or_index.path.split('/').pop()\n  var tmp4 = tmp3.split('.').pop()\n  if (tmp4 == 'tar' || tmp4 == 'TAR') {\n    return \"\"\n  } else {\n    return \"&& tar -vcf \" + x1 + \".\" + x2 + \"star-2.5.4b-index-archive.tar ./genomeDir \"\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 99
          }
        ],
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "inputs": [
          {
            "label": "Extra alignment score",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbScore"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "2",
            "id": "#sjdbScore",
            "description": "Extra alignment score for alignments that cross database junctions."
          },
          {
            "label": "\"Overhang\" length",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbOverhang"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "100",
            "id": "#sjdbOverhang",
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used."
          },
          {
            "label": "Exon parent name",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFtagExonParentTranscript"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "transcript_id",
            "id": "#sjdbGTFtagExonParentTranscript",
            "description": "Tag name to be used as exons transcript-parents."
          },
          {
            "label": "Gene name",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFtagExonParentGene"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "gene_id",
            "id": "#sjdbGTFtagExonParentGene",
            "description": "Tag name to be used as exons gene-parents."
          },
          {
            "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
            "label": "Splice junction file",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFfile",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "sbg:category": "Basic",
            "id": "#sjdbGTFfile",
            "description": "Gene annotation file in GTF/GFF format. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\".",
            "sbg:stageInput": "link"
          },
          {
            "label": "Set exons feature",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFfeatureExon"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "exon",
            "id": "#sjdbGTFfeatureExon",
            "description": "Feature type in GTF file to be used as exons for building transcripts."
          },
          {
            "label": "Chromosome names",
            "sbg:category": "Splice junctions db parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFchrPrefix"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#sjdbGTFchrPrefix",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes)."
          },
          {
            "sbg:fileTypes": "TXT,SJDB,TAB",
            "label": "List of annotated junctions",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbFileChrStartEnd",
              "itemSeparator": null
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "sbg:category": "Basic",
            "id": "#sjdbFileChrStartEnd",
            "description": "List of splice junction coordinates in a tab-separated file."
          },
          {
            "label": "Number of threads",
            "sbg:category": "Run parameters",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "16",
            "id": "#runThreadN",
            "description": "Number of threads to use."
          },
          {
            "sbg:fileTypes": "FASTA, FA, FNA, TAR",
            "label": "Reference/Index files",
            "required": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeFastaFiles"
            },
            "type": [
              "File"
            ],
            "sbg:category": "Basic",
            "id": "#reference_or_index",
            "description": "Reference sequence to which to align the reads, or a TAR bundle containing already generated indices.",
            "sbg:stageInput": "link"
          },
          {
            "label": "Limit Genome Generate RAM",
            "sbg:category": "Run parameters",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  return $job.inputs.limitGenomeGenerateRAM ? $job.inputs.limitGenomeGenerateRAM*1000000000 : 60000000000\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitGenomeGenerateRAM",
              "position": 0
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "60",
            "id": "#limitGenomeGenerateRAM",
            "description": "Upper RAM limit for genome generation, in GB."
          },
          {
            "label": "Maximum genome suffic length",
            "sbg:category": "Genome generation parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeSuffixLengthMax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "id": "#genomeSuffixLengthMax",
            "description": "Maximum length of the suffixes, has to be longer than read length. -1 = infinite."
          },
          {
            "label": "Suffux array sparsity",
            "sbg:category": "Genome generation parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeSAsparseD"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1",
            "id": "#genomeSAsparseD",
            "description": "Distance between indices: use bigger numbers to decrease needed RAM at the cost of mapping speed reduction (int>0)."
          },
          {
            "label": "Pre-indexing string length",
            "sbg:category": "Genome generation parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeSAindexNbases"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "14",
            "id": "#genomeSAindexNbases",
            "description": "Length (bases) of the SA pre-indexing string. Typically between 10 and 15. Longer strings will use much more memory, but allow faster searches. For small genomes, this number needs to be scaled down, with a typical value of min(14, log2(GenomeLength)/2 - 1). For example, for 1 megaBase genome, this is equal to 9, for 100 kiloBase genome, this is equal to 7."
          },
          {
            "label": "Bins size",
            "sbg:category": "Genome generation parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeChrBinNbits"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "18",
            "id": "#genomeChrBinNbits",
            "description": "Set log2(chrBin), where chrBin is the size (bits) of the bins for genome storage: each chromosome will occupy an integer number of bins. If you are using a genome with a large (>5,000) number of chrosomes/scaffolds, you may need to reduce this number to reduce RAM consumption. The following scaling is recomended: genomeChrBinNbits = min(18, log2(GenomeLength/NumberOfReferences)). For example, for 3 gigaBase genome with 100,000 chromosomes/scaffolds, this is equal to 15.",
            "sbg:stageInput": null
          }
        ],
        "sbg:revision": 5,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "class": "CommandLineTool",
        "sbg:latestRevision": 5,
        "id": "uros_sipetic/star-2-5-4b-demo/star-genome-generate-2-5-4b/5",
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/alexdobin/STAR/archive/2.5.4b.tar.gz",
            "label": "Download"
          },
          {
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          },
          {
            "id": "http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf",
            "label": "Documentation"
          }
        ],
        "sbg:modifiedBy": "uros_sipetic",
        "sbg:toolkit": "STAR",
        "sbg:image_url": null,
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "label": "STAR Genome Generate",
        "sbg:categories": [
          "Alignment",
          "RNA"
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:modifiedOn": 1521460183,
        "sbg:id": "admin/sbg-public-data/star-genome-generate-2-5-4b/5",
        "temporaryFailCodes": [],
        "stdin": ""
      },
      "id": "#STAR_Genome_Generate",
      "sbg:y": 428.4672820687532
    },
    {
      "sbg:x": 531.4283090102808,
      "inputs": [
        {
          "source": [
            "#reads"
          ],
          "id": "#STAR.reads"
        },
        {
          "id": "#STAR.readMatesLengthsIn"
        },
        {
          "id": "#STAR.readMapNumber"
        },
        {
          "id": "#STAR.limitOutSJoneRead"
        },
        {
          "id": "#STAR.limitOutSJcollapsed"
        },
        {
          "source": [
            "#outReadsUnmapped"
          ],
          "id": "#STAR.outReadsUnmapped",
          "default": "Fastx"
        },
        {
          "id": "#STAR.outQSconversionAdd"
        },
        {
          "source": [
            "#outSAMtype"
          ],
          "id": "#STAR.outSAMtype"
        },
        {
          "source": [
            "#outSortingType"
          ],
          "id": "#STAR.outSortingType",
          "default": "SortedByCoordinate"
        },
        {
          "id": "#STAR.outSAMmode"
        },
        {
          "source": [
            "#outSAMstrandField"
          ],
          "id": "#STAR.outSAMstrandField"
        },
        {
          "id": "#STAR.outSAMattributes"
        },
        {
          "source": [
            "#outSAMunmapped"
          ],
          "id": "#STAR.outSAMunmapped",
          "default": "Within KeepPairs"
        },
        {
          "source": [
            "#outSAMorder"
          ],
          "id": "#STAR.outSAMorder"
        },
        {
          "id": "#STAR.outSAMprimaryFlag"
        },
        {
          "id": "#STAR.outSAMreadID"
        },
        {
          "id": "#STAR.outSAMmapqUnique"
        },
        {
          "id": "#STAR.outSAMflagOR"
        },
        {
          "id": "#STAR.outSAMflagAND"
        },
        {
          "id": "#STAR.outSAMheaderHD"
        },
        {
          "id": "#STAR.outSAMheaderPG"
        },
        {
          "id": "#STAR.rg_seq_center"
        },
        {
          "id": "#STAR.rg_library_id"
        },
        {
          "id": "#STAR.rg_mfl"
        },
        {
          "id": "#STAR.rg_platform"
        },
        {
          "id": "#STAR.rg_platform_unit_id"
        },
        {
          "id": "#STAR.rg_sample_id"
        },
        {
          "id": "#STAR.outFilterType"
        },
        {
          "id": "#STAR.outFilterMultimapScoreRange"
        },
        {
          "id": "#STAR.outFilterMultimapNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverReadLmax"
        },
        {
          "id": "#STAR.outFilterScoreMin"
        },
        {
          "id": "#STAR.outFilterScoreMinOverLread"
        },
        {
          "id": "#STAR.outFilterMatchNmin"
        },
        {
          "id": "#STAR.outFilterMatchNminOverLread"
        },
        {
          "id": "#STAR.outFilterIntronMotifs"
        },
        {
          "id": "#STAR.outSJfilterReads"
        },
        {
          "id": "#STAR.outSJfilterOverhangMin"
        },
        {
          "id": "#STAR.outSJfilterCountUniqueMin"
        },
        {
          "id": "#STAR.outSJfilterCountTotalMin"
        },
        {
          "id": "#STAR.outSJfilterDistToOtherSJmin"
        },
        {
          "id": "#STAR.outSJfilterIntronMaxVsReadN"
        },
        {
          "id": "#STAR.scoreGap"
        },
        {
          "id": "#STAR.scoreGapNoncan"
        },
        {
          "id": "#STAR.scoreGapGCAG"
        },
        {
          "id": "#STAR.scoreGapATAC"
        },
        {
          "id": "#STAR.scoreGenomicLengthLog2scale"
        },
        {
          "id": "#STAR.scoreDelOpen"
        },
        {
          "id": "#STAR.scoreDelBase"
        },
        {
          "id": "#STAR.scoreInsOpen"
        },
        {
          "id": "#STAR.scoreInsBase"
        },
        {
          "id": "#STAR.scoreStitchSJshift"
        },
        {
          "id": "#STAR.seedSearchStartLmax"
        },
        {
          "id": "#STAR.seedSearchStartLmaxOverLread"
        },
        {
          "id": "#STAR.seedSearchLmax"
        },
        {
          "id": "#STAR.seedMultimapNmax"
        },
        {
          "id": "#STAR.seedPerReadNmax"
        },
        {
          "id": "#STAR.seedPerWindowNmax"
        },
        {
          "id": "#STAR.seedNoneLociPerWindow"
        },
        {
          "id": "#STAR.alignIntronMin"
        },
        {
          "id": "#STAR.alignIntronMax"
        },
        {
          "id": "#STAR.alignMatesGapMax"
        },
        {
          "id": "#STAR.alignSJoverhangMin"
        },
        {
          "id": "#STAR.alignSJDBoverhangMin"
        },
        {
          "id": "#STAR.alignSplicedMateMapLmin"
        },
        {
          "id": "#STAR.alignSplicedMateMapLminOverLmate"
        },
        {
          "id": "#STAR.alignWindowsPerReadNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerWindowNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerReadNmax"
        },
        {
          "id": "#STAR.alignEndsType"
        },
        {
          "id": "#STAR.alignSoftClipAtReferenceEnds"
        },
        {
          "id": "#STAR.winAnchorMultimapNmax"
        },
        {
          "id": "#STAR.winBinNbits"
        },
        {
          "id": "#STAR.winAnchorDistNbins"
        },
        {
          "id": "#STAR.winFlankNbins"
        },
        {
          "source": [
            "#chimSegmentMin"
          ],
          "id": "#STAR.chimSegmentMin",
          "default": 12
        },
        {
          "id": "#STAR.chimScoreMin"
        },
        {
          "id": "#STAR.chimScoreDropMax"
        },
        {
          "id": "#STAR.chimScoreSeparation"
        },
        {
          "id": "#STAR.chimScoreJunctionNonGTAG"
        },
        {
          "id": "#STAR.chimJunctionOverhangMin"
        },
        {
          "source": [
            "#quantMode"
          ],
          "id": "#STAR.quantMode",
          "default": "TranscriptomeSAM GeneCounts"
        },
        {
          "source": [
            "#twopass1readsN"
          ],
          "id": "#STAR.twopass1readsN"
        },
        {
          "source": [
            "#twopassMode"
          ],
          "id": "#STAR.twopassMode",
          "default": "Basic"
        },
        {
          "id": "#STAR.genomeDirName"
        },
        {
          "id": "#STAR.sjdbInsertSave"
        },
        {
          "id": "#STAR.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentTranscript"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentGene"
        },
        {
          "source": [
            "#sjdbOverhang_1"
          ],
          "id": "#STAR.sjdbOverhang"
        },
        {
          "id": "#STAR.sjdbScore"
        },
        {
          "source": [
            "#sjdbGTFfile"
          ],
          "id": "#STAR.sjdbGTFfile"
        },
        {
          "id": "#STAR.clip3pNbases"
        },
        {
          "id": "#STAR.clip5pNbases"
        },
        {
          "id": "#STAR.clip3pAdapterSeq"
        },
        {
          "id": "#STAR.clip3pAdapterMMp"
        },
        {
          "id": "#STAR.clip3pAfterAdapterNbases"
        },
        {
          "source": [
            "#chimOutType"
          ],
          "id": "#STAR.chimOutType"
        },
        {
          "source": [
            "#STAR_Genome_Generate.genome"
          ],
          "id": "#STAR.genome"
        },
        {
          "id": "#STAR.limitSjdbInsertNsj"
        },
        {
          "source": [
            "#quantTranscriptomeBan"
          ],
          "id": "#STAR.quantTranscriptomeBan"
        },
        {
          "source": [
            "#limitBAMsortRAM"
          ],
          "id": "#STAR.limitBAMsortRAM"
        },
        {
          "id": "#STAR.outSAMmultNmax"
        },
        {
          "id": "#STAR.outMultimapperOrder"
        },
        {
          "id": "#STAR.outSAMattrIHstart"
        },
        {
          "id": "#STAR.outSAMfilter"
        },
        {
          "id": "#STAR.alignSJstitchMismatchNmax"
        },
        {
          "id": "#STAR.chimSegmentReadGapMax"
        },
        {
          "source": [
            "#chimFilter"
          ],
          "id": "#STAR.chimFilter"
        },
        {
          "source": [
            "#unmappedOutputName"
          ],
          "id": "#STAR.unmappedOutputName"
        },
        {
          "source": [
            "#no_read_groups"
          ],
          "id": "#STAR.no_read_groups"
        },
        {
          "source": [
            "#sortUnmappedReads"
          ],
          "id": "#STAR.sortUnmappedReads",
          "default": true
        },
        {
          "id": "#STAR.sjdbFileChrStartEnd"
        },
        {
          "source": [
            "#runThreadN"
          ],
          "id": "#STAR.runThreadN"
        },
        {
          "id": "#STAR.alignEndsProtrude"
        },
        {
          "id": "#STAR.chimMainSegmentMultNmax"
        },
        {
          "source": [
            "#outFileNamePrefix"
          ],
          "id": "#STAR.outFileNamePrefix"
        },
        {
          "source": [
            "#bamRemoveDuplicatesType"
          ],
          "id": "#STAR.bamRemoveDuplicatesType"
        },
        {
          "source": [
            "#bamRemoveDuplicatesMate2basesN"
          ],
          "id": "#STAR.bamRemoveDuplicatesMate2basesN"
        },
        {
          "id": "#STAR.outWigType"
        },
        {
          "id": "#STAR.outWigStrand"
        },
        {
          "id": "#STAR.outWigReferencePrefix"
        },
        {
          "id": "#STAR.outWigNorm"
        },
        {
          "id": "#STAR.outFilterIntronStrands"
        },
        {
          "id": "#STAR.seedSplitMin"
        }
      ],
      "outputs": [
        {
          "id": "#STAR.aligned_reads"
        },
        {
          "id": "#STAR.transcriptome_aligned_reads"
        },
        {
          "id": "#STAR.reads_per_gene"
        },
        {
          "id": "#STAR.log_files"
        },
        {
          "id": "#STAR.splice_junctions"
        },
        {
          "id": "#STAR.chimeric_junctions"
        },
        {
          "id": "#STAR.unmapped_reads"
        },
        {
          "id": "#STAR.intermediate_genome"
        },
        {
          "id": "#STAR.chimeric_alignments"
        },
        {
          "id": "#STAR.wiggle_files"
        }
      ],
      "run": {
        "sbg:sbgMaintained": false,
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:revisionNotes": "Changes made to reads JS expression in order to handle multiple samples on input.",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/uros_sipetic/star:2.5.4b",
            "dockerImageId": ""
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n  return $job.inputs.runThreadN ? $job.inputs.runThreadN : 32\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:latestRevision": 7,
        "sbg:publisher": "sbg",
        "sbg:projectName": "STAR 2.5.4b - Demo",
        "sbg:createdOn": 1519136392,
        "successCodes": [],
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20genome.ext && STAR --runThreadN 6 --readFilesCommand zcat  --sjdbGTFchrPrefix chrPrefix --sjdbInsertSave Basic  --twopass1readsN -1  --chimOutType WithinBAM SoftClip  --outSAMattrRGline ID:1_EGFR_Dead_CD4_0h_S1_L004 PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample , ID:1_EGFR_Dead_CD4_0h_S1_L003 PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample , ID:1_EGFR_Dead_CD4_0h_S1_L002 PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample , ID:1_EGFR_Dead_CD4_0h_S1_L001 PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample  --quantMode TranscriptomeSAM --outFileNamePrefix ./1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.  --readFilesIn /path/to/file/1_EGFR_Dead_CD4_0h_S1_L004_R1_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L003_R1_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L002_R1_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L001_R1_001.fastq.gz /path/to/file/1_EGFR_Dead_CD4_0h_S1_L004_R2_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L003_R2_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L002_R2_001.fastq.gz,/path/to/file/1_EGFR_Dead_CD4_0h_S1_L001_R2_001.fastq.gz  && tar -vcf 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic._STARgenome.tar ./1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic._STARgenome   && cat 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate2 | sed 's/\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\t' '\\n' > 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate2.fastq && rm 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate2 && cat 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate1 | sed 's/\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\t' '\\n' > 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate1.fastq && rm 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Unmapped.out.mate1 ; samtools index 1_EGFR_Dead_CD4_0h_S1_L004.twopass-basic.Aligned.sortedByCoord.out.bam",
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 6
          },
          "inputs": {
            "outMultimapperOrder": "Random",
            "seedSplitMin": 7,
            "alignMatesGapMax": 0,
            "winAnchorDistNbins": 0,
            "alignSJDBoverhangMin": 0,
            "alignEndsProtrude": "alignEndsProtrude-string-value",
            "limitBAMsortRAM": null,
            "reads": [
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L004_R1_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L004"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L003_R1_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L003"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L002_R1_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L002"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L001_R1_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L001"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L004_R2_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L004"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L003_R2_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L003"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L001_R2_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L001"
                }
              },
              {
                "path": "/path/to/file/1_EGFR_Dead_CD4_0h_S1_L002_R2_001.fastq.gz",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2",
                  "sample_id": "1_EGFR_Dead_CD4_0h_S1_L002"
                }
              }
            ],
            "alignSJstitchMismatchNmax": "alignSJstitchMismatchNmax-string-value",
            "limitOutSJoneRead": 0,
            "outSJfilterReads": "All",
            "outWigType": "bedGraph",
            "outSAMmode": "Full",
            "chimSegmentReadGapMax": 8,
            "alignTranscriptsPerReadNmax": 0,
            "quantTranscriptomeBan": "IndelSoftclipSingleend",
            "sjdbOverhang": null,
            "winBinNbits": 0,
            "outSJfilterIntronMaxVsReadN": [
              0
            ],
            "chimScoreJunctionNonGTAG": 0,
            "bamRemoveDuplicatesMate2basesN": 9,
            "twopass1readsN": -1,
            "alignIntronMax": 0,
            "runThreadN": 6,
            "outSAMattributes": "Standard",
            "outSJfilterCountTotalMin": [
              3,
              1,
              1,
              1
            ],
            "limitOutSJcollapsed": 0,
            "rg_platform": "Ion Torrent PGM",
            "sortUnmappedReads": true,
            "outFilterMismatchNoverLmax": 0,
            "chimOutType": "Within SoftClip",
            "seedNoneLociPerWindow": 0,
            "outFilterMatchNminOverLread": 0,
            "outFilterIntronMotifs": "None",
            "outSAMfilter": "KeepOnlyAddedReference",
            "alignWindowsPerReadNmax": 0,
            "winAnchorMultimapNmax": 0,
            "chimJunctionOverhangMin": 0,
            "chimScoreMin": 0,
            "clip3pAdapterSeq": [
              "clip3pAdapterSeq"
            ],
            "outSAMflagOR": 0,
            "rg_mfl": "rg_mfl",
            "outSJfilterOverhangMin": [
              30,
              12,
              12,
              12
            ],
            "outSAMorder": "Paired",
            "sjdbFileChrStartEnd": null,
            "alignEndsType": "Local",
            "rg_seq_center": "",
            "outWigReferencePrefix": "outWigReferencePrefix-string-value",
            "outSAMattrIHstart": 6,
            "outSAMtype": "BAM",
            "rg_platform_unit_id": "rg_platform_unit",
            "clip3pAdapterMMp": [
              0
            ],
            "scoreGapATAC": 0,
            "unmappedOutputName": "",
            "chimFilter": "banGenomicN",
            "clip3pAfterAdapterNbases": [
              0
            ],
            "outWigStrand": "solexa-qualss",
            "alignSoftClipAtReferenceEnds": "Yes",
            "scoreInsOpen": 0,
            "outFilterMultimapScoreRange": 0,
            "chimScoreSeparation": 0,
            "sjdbGTFfile": [
              {
                "path": "/demo/test-data/chr20gtf.gtf"
              }
            ],
            "genomeDirName": "",
            "scoreGap": 0,
            "no_read_groups": false,
            "scoreInsBase": 0,
            "GENOME_DIR_NAME": "",
            "scoreGapGCAG": 0,
            "seedSearchStartLmaxOverLread": 0,
            "chimMainSegmentMultNmax": 9,
            "seedPerWindowNmax": 0,
            "outFilterIntronStrands": null,
            "outQSconversionAdd": 0,
            "readMatesLengthsIn": "NotEqual",
            "outFilterScoreMinOverLread": 0,
            "genome": {
              "path": "chr20genome.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "rg_library_id": "",
            "outWigNorm": "None",
            "outFilterMismatchNmax": 0,
            "outFilterMismatchNoverReadLmax": 0,
            "seedPerReadNmax": 0,
            "outFilterMatchNmin": 0,
            "chimSegmentMin": 15,
            "quantMode": "TranscriptomeSAM",
            "winFlankNbins": 0,
            "alignSJoverhangMin": 0,
            "scoreStitchSJshift": 0,
            "sjdbGTFtagExonParentGene": "",
            "alignSplicedMateMapLmin": 0,
            "outFilterMultimapNmax": 0,
            "seedSearchLmax": 0,
            "seedMultimapNmax": 0,
            "sjdbGTFchrPrefix": "chrPrefix",
            "clip5pNbases": [
              0
            ],
            "sjdbInsertSave": "Basic",
            "outFileNamePrefix": "",
            "readMapNumber": 0,
            "chimScoreDropMax": 0,
            "sjdbGTFfeatureExon": "",
            "scoreDelOpen": 0,
            "sjdbScore": null,
            "alignSplicedMateMapLminOverLmate": 0,
            "outSAMunmapped": "None",
            "outFilterScoreMin": 0,
            "outSJfilterDistToOtherSJmin": [
              0
            ],
            "outReadsUnmapped": "Fastx",
            "outSJfilterCountUniqueMin": [
              3,
              1,
              1,
              1
            ],
            "scoreGapNoncan": 0,
            "outSAMmultNmax": 0,
            "scoreGenomicLengthLog2scale": 0,
            "rg_sample_id": "rg_sample",
            "sjdbGTFtagExonParentTranscript": "",
            "outSAMmapqUnique": 0,
            "bamRemoveDuplicatesType": "UniqueIdentical",
            "clip3pNbases": [
              0,
              3
            ],
            "scoreDelBase": 0,
            "outSAMprimaryFlag": "OneBestScore",
            "limitSjdbInsertNsj": 0,
            "seedSearchStartLmax": 0,
            "outSAMheaderPG": "outSAMheaderPG",
            "twopassMode": "Basic",
            "outFilterType": "Normal",
            "alignIntronMin": 0,
            "outSortingType": "SortedByCoordinate",
            "alignTranscriptsPerWindowNmax": 0,
            "outSAMheaderHD": "outSAMheaderHD",
            "outSAMflagAND": 0,
            "outSAMstrandField": "None",
            "outSAMreadID": "Standard"
          }
        },
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/alexdobin/STAR/archive/2.5.4b.tar.gz",
            "label": "Download"
          },
          {
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          },
          {
            "id": "http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf",
            "label": "Documentation"
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "outputs": [
          {
            "sbg:fileTypes": "SAM,BAM",
            "label": "Aligned SAM/BAM",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.outSortingType == 'SortedByCoordinate') {\n    sort_name = '.sortedByCoord'\n  }\n  else {\n    sort_name = ''\n  }\n  if ($job.inputs.outSAMtype == 'SAM') {\n    sam_name = \"*.Aligned.out.sam\"\n  }\n  else {\n    sam_name = \"*.Aligned\".concat( sort_name, '.out.bam')\n  }\n  return sam_name\n}",
                "engine": "#cwl-js-engine"
              },
              "secondaryFiles": [
                ".bai"
              ],
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  var arr = [].concat($job.inputs.reads)\n  \n  if ($job.inputs.outFileNamePrefix) {\n    return $job.inputs.outFileNamePrefix \n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    return arr[0].metadata.sample_id \n  } else {\n    return arr[0].path.split('/').pop().split('.')[0]\n  }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "id": "#aligned_reads",
            "description": "Aligned sequence in SAM/BAM format."
          },
          {
            "sbg:fileTypes": "SAM,BAM",
            "label": "Transcriptome alignments",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Transcriptome*",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  var arr = [].concat($job.inputs.reads)\n\n  if ($job.inputs.outFileNamePrefix) {\n    return $job.inputs.outFileNamePrefix\n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    return arr[0].metadata.sample_id \n  } else {\n    return arr[0].path.split('/').pop().split('.')[0]\n  }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "id": "#transcriptome_aligned_reads",
            "description": "Alignments translated into transcript coordinates."
          },
          {
            "sbg:fileTypes": "TAB",
            "label": "Reads per gene",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*ReadsPerGene*",
              "sbg:metadata": {}
            },
            "id": "#reads_per_gene",
            "description": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene."
          },
          {
            "sbg:fileTypes": "OUT",
            "label": "Log files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Log*.out",
              "sbg:metadata": {}
            },
            "id": "#log_files",
            "description": "Log files produced during alignment."
          },
          {
            "sbg:fileTypes": "TAB",
            "label": "Splice junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*SJ.out.tab",
              "sbg:metadata": {}
            },
            "id": "#splice_junctions",
            "description": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported."
          },
          {
            "sbg:fileTypes": "JUNCTION",
            "label": "Chimeric junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Chimeric.out.junction"
            },
            "id": "#chimeric_junctions",
            "description": "Chimeric junctions file. If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output."
          },
          {
            "sbg:fileTypes": "FASTQ",
            "label": "Unmapped reads",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.unmappedOutputName) {\n    return \"*\" + $job.inputs.unmappedOutputName + \"*\"\n  } else {\n    return \"*Unmapped.out*\"\n  }\n  \n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  var arr = [].concat($job.inputs.reads)\n  \n  if ($job.inputs.outFileNamePrefix) {\n    return $job.inputs.outFileNamePrefix \n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    return arr[0].metadata.sample_id \n  } else {\n    return arr[0].path.split('/').pop().split('.')[0]\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  if ($self) {\n    filename = $self.path.split(\"/\").pop();\n    if (filename.lastIndexOf(\".fast\") !== 0){\n      return filename[filename.lastIndexOf(\".fast\") - 1 ]\n    } else {\n      return \"\"\n    } \n  } else {\n    return \"\"\n  }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "id": "#unmapped_reads",
            "description": "Unmapped reads in FASTQ format."
          },
          {
            "sbg:fileTypes": "TAR",
            "label": "Intermediate genome files",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*_STARgenome.tar",
              "sbg:metadata": {}
            },
            "id": "#intermediate_genome",
            "description": "Archive with genome files produced when annotations are included on the fly (in the mapping step)."
          },
          {
            "sbg:fileTypes": "SAM",
            "label": "Chimeric alignments",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*.Chimeric.out.sam",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "id": "#chimeric_alignments",
            "description": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs."
          },
          {
            "sbg:fileTypes": "WIG,BG",
            "label": "Wiggle files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "{*.wig, *.bg}"
            },
            "id": "#wiggle_files",
            "description": "Wiggle output files (either wiggle or bedgraph, depending on which input parameter is set)."
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1519136392,
            "sbg:revisionNotes": "Copy of uros_sipetic/star-2-5-3a-demo/star-2-5-3-a/26",
            "sbg:revision": 0
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1519140781,
            "sbg:revisionNotes": "Initial set-up",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1519150371,
            "sbg:revisionNotes": "Bump to 2.5.4b",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1521213522,
            "sbg:revisionNotes": "Update description.",
            "sbg:revision": 3
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1523965147,
            "sbg:revisionNotes": "Add BAM indexing",
            "sbg:revision": 4
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1524670037,
            "sbg:revisionNotes": "Set the described default value on outSAMtype to 'BAM'.",
            "sbg:revision": 5
          },
          {
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1526389045,
            "sbg:revisionNotes": "Fix small bug regarding unmapped reads output paired_end metadata inheritance.",
            "sbg:revision": 6
          },
          {
            "sbg:modifiedBy": "nemanja.vucic",
            "sbg:modifiedOn": 1551092161,
            "sbg:revisionNotes": "Changes made to reads JS expression in order to handle multiple samples on input.",
            "sbg:revision": 7
          }
        ],
        "sbg:image_url": null,
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  arr = [].concat($job.inputs.reads)\n  ext = arr[0].path.split('.').pop().toLowerCase()\n  if (ext == \"gz\") {\n    return \"zcat\"\n  } else if (ext == \"bz2\") {\n    return \"bzcat\"\n  } else if (ext == 'bam') {\n    return \"samtools view -h\"\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "--readFilesCommand"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  a = b = c = d = e = f = g = []\n  if ($job.inputs.sjdbGTFchrPrefix) {\n    a = [\"--sjdbGTFchrPrefix\", $job.inputs.sjdbGTFchrPrefix]\n  }\n  if ($job.inputs.sjdbGTFfeatureExon) {\n    b = [\"--sjdbGTFfeatureExon\", $job.inputs.sjdbGTFfeatureExon]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentTranscript) {\n    c = [\"--sjdbGTFtagExonParentTranscript\", $job.inputs.sjdbGTFtagExonParentTranscript]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentGene) {\n    d = [\"--sjdbGTFtagExonParentGene\", $job.inputs.sjdbGTFtagExonParentGene]\n  }\n  if ($job.inputs.sjdbOverhang) {\n    e = [\"--sjdbOverhang\", $job.inputs.sjdbOverhang]\n  }\n  if ($job.inputs.sjdbScore) {\n    f = [\"--sjdbScore\", $job.inputs.sjdbScore]\n  }\n  if ($job.inputs.sjdbInsertSave) {\n    g = [\"--sjdbInsertSave\", $job.inputs.sjdbInsertSave]\n  }\n  \n  \n  \n  if ($job.inputs.sjdbInsertSave != \"None\" && ($job.inputs.sjdbGTFfile || $job.inputs.sjdbFileChrStartEnd)) {\n    new_list = a.concat(b, c, d, e, f, g)\n    return new_list.join(\" \")\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.twopassMode == \"Basic\") {\n    if ($job.inputs.twopass1readsN) {\n      return \"--twopass1readsN \".concat($job.inputs.twopass1readsN) \n    } else {\n      return \"--twopass1readsN -1\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.chimOutType == \"Within HardClip\") {\n    return \"--chimOutType \".concat(\"Within\", $job.inputs.outSAMtype, \" HardClip\")\n  }\n  else if ($job.inputs.chimOutType == \"Within SoftClip\") {\n    return \"--chimOutType \".concat(\"Within\", $job.inputs.outSAMtype, \" SoftClip\")\n  }\n  else {\n    return \"--chimOutType SeparateSAMold\"\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if ($job.inputs.no_read_groups) {\n  return \"\" }\n  else {\n  var param_list = []\n  var all_samples = []\n  var list = [].concat($job.inputs.reads)\n  getUnique = function(arr){\n    var u = {}, a = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n      if(u.hasOwnProperty(arr[i])) {\n        continue;\n      }\n      a.push(arr[i]);\n      u[arr[i]] = 1;\n    }\n    return a;\n  }\n  \n  function add_param(key, value){\n    if (value == \"\") {\n      return\n    }\n    else {\n      return param_list.push(key.concat(\":\", value))\n    }\n  }\n  for (index = 0; index < list.length; ++index) {\n    if (list[index].metadata != null){\n    \tif (list[index].metadata.sample_id != null){\n      \t\tall_samples.push(list[index].metadata.sample_id)\n      }\n    }\n  }\n  \n  samples = getUnique(all_samples)\n  var samples_given = all_samples.length == list.length\n  var all_rg = []\n  if (samples_given){\n    for (sample_ind = 0; sample_ind < samples.length; ++sample_ind){\n    \tfor (read_ind = 0; read_ind < list.length; ++read_ind) {\n        var param_list = []\n        if (list[read_ind].metadata && list[read_ind].metadata.sample_id == samples[sample_ind] && list[read_ind].metadata.paired_end != \"2\") {\n        \tadd_param('ID', samples[sample_ind])\n          if ($job.inputs.rg_seq_center) {\n            add_param('CN', $job.inputs.rg_seq_center)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.seq_center) {\n            add_param('CN', list[read_ind].metadata.seq_center)\n          }\n          if ($job.inputs.rg_library_id) {\n            add_param('LB', $job.inputs.rg_library_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.library_id) {\n            add_param('LB', list[read_ind].metadata.library_id)\n          }\n          if ($job.inputs.rg_mfl) {\n            add_param('PI', $job.inputs.rg_mfl)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.median_fragment_length) {\n            add_param('PI', list[read_ind].metadata.median_fragment_length)\n          }\n          if ($job.inputs.rg_platform) {\n            add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n          } else if (list[read_ind].metadata && list[read_ind].metadata.platform) {\n            add_param('PL', list[read_ind].metadata.platform.replace(/ /g,\"_\"))\n          }\n          if ($job.inputs.rg_platform_unit_id) {\n            add_param('PU', $job.inputs.rg_platform_unit_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.platform_unit_id) {\n            add_param('PU', list[read_ind].metadata.platform_unit_id)\n          }\n          if ($job.inputs.rg_sample_id) {\n            add_param('SM', $job.inputs.rg_sample_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.sample_id) {\n            add_param('SM', list[read_ind].metadata.sample_id)\n          }\n          all_rg.push(param_list.join(\" \"))\n       }\n\n    }\n   }\n  } else {\n  \tvar param_list = []\n    add_param('ID', \"1\")\n    if ($job.inputs.rg_seq_center) {\n      add_param('CN', $job.inputs.rg_seq_center)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.seq_center) {\n      add_param('CN', [].concat($job.inputs.reads)[0].metadata.seq_center)\n    }\n    if ($job.inputs.rg_library_id) {\n      add_param('LB', $job.inputs.rg_library_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.library_id) {\n      add_param('LB', [].concat($job.inputs.reads)[0].metadata.library_id)\n    }\n    if ($job.inputs.rg_mfl) {\n      add_param('PI', $job.inputs.rg_mfl)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.median_fragment_length) {\n      add_param('PI', [].concat($job.inputs.reads)[0].metadata.median_fragment_length)\n    }\n    if ($job.inputs.rg_platform) {\n      add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.platform) {\n      add_param('PL', [].concat($job.inputs.reads)[0].metadata.platform.replace(/ /g,\"_\"))\n    }\n    if ($job.inputs.rg_platform_unit_id) {\n      add_param('PU', $job.inputs.rg_platform_unit_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.platform_unit_id) {\n      add_param('PU', [].concat($job.inputs.reads)[0].metadata.platform_unit_id)\n    }\n    if ($job.inputs.rg_sample_id) {\n      add_param('SM', $job.inputs.rg_sample_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.sample_id) {\n      add_param('SM', [].concat($job.inputs.reads)[0].metadata.sample_id)\n    }\n    return \"--outSAMattrRGline \".concat(param_list.join(\" \"))\n  }\n  return \"--outSAMattrRGline \".concat(all_rg.join(\" , \"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if (($job.inputs.sjdbGTFfile || $job.inputs.sjdbFileChrStartEnd) && $job.inputs.quantMode) {\n    return \"--quantMode \".concat($job.inputs.quantMode)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var arr = [].concat($job.inputs.reads)\n\n  if ($job.inputs.sjdbFileChrStartEnd) {\n    twopass = \".twopass-multiple.\"\n  } else if ($job.inputs.twopassMode=='Basic') {\n    twopass = \".twopass-basic.\"\n  } else {\n    twopass = \".\"\n  }\n  \n  if ($job.inputs.outFileNamePrefix) {\n    intermediate = $job.inputs.outFileNamePrefix + twopass + \"_STARgenome\"\n  \tsource = \"./\".concat(intermediate)\n  \tdestination = intermediate.concat(\".tar\")\n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    intermediate = arr[0].metadata.sample_id + twopass + \"_STARgenome\"\n    source = \"./\".concat(intermediate)\n  \tdestination = intermediate.concat(\".tar\")\n  } else {\n    intermediate = arr[0].path.split('/').pop().split('.')[0] + twopass + \"_STARgenome\"\n    source = \"./\".concat(intermediate)\n  \tdestination = intermediate.concat(\".tar\")\n  }\n  if (($job.inputs.sjdbGTFfile || $job.inputs.sjdbFileChrStartEnd) && $job.inputs.sjdbInsertSave && $job.inputs.sjdbInsertSave != \"None\") {\n    return \"&& tar -vcf \".concat(destination, \" \", source)\n  }\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var arr = [].concat($job.inputs.reads)\n\n  if ($job.inputs.sjdbFileChrStartEnd) {\n    twopass = \".twopass-multiple.\"\n  } else if ($job.inputs.twopassMode=='Basic') {\n    twopass = \".twopass-basic.\"\n  } else {\n    twopass = \".\"\n  }\n  \n  if ($job.inputs.outFileNamePrefix) {\n    return './' + $job.inputs.outFileNamePrefix + twopass\n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    return './' + arr[0].metadata.sample_id + twopass\n  } else {\n    return \"./\" + arr[0].path.split('/').pop().split('.')[0] + twopass\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "--outFileNamePrefix"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var arr = [].concat($job.inputs.reads)\n  \n  if ($job.inputs.sjdbFileChrStartEnd) {\n    twopass = \".twopass-multiple.\"\n  } else if ($job.inputs.twopassMode=='Basic') {\n    twopass = \".twopass-basic.\"\n  } else {\n    twopass = \".\"\n  }\n  \n  if ($job.inputs.outFileNamePrefix) {\n    common_prefix = $job.inputs.outFileNamePrefix + twopass\n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    common_prefix = arr[0].metadata.sample_id + twopass\n  } else {\n    common_prefix = arr[0].path.split('/').pop().split('.')[0] + twopass\n  }\n  mate1 = common_prefix.concat(\"Unmapped.out.mate1\")\n  mate2 = common_prefix.concat(\"Unmapped.out.mate2\")\n  var x = arr[0].path.split('/').pop()\n  var y = x.toLowerCase()\n  \n  if ($job.inputs.unmappedOutputName) {\n  \tvar output_name = $job.inputs.unmappedOutputName + \".\"\n  } else {\n    var output_name = \"Unmapped.out.\"\n  }\n  \n  mate1_1 = common_prefix.concat(output_name + \"mate1\")\n  mate2_1 = common_prefix.concat(output_name + \"mate2\")\n  \n  \n  if (y.endsWith('fastq') || y.endsWith('fq') || y.endsWith('fastq.gz') || y.endsWith('fastq.bz2') || y.endsWith('fq.gz') || y.endsWith('fq.bz2') || y.endsWith('bam') || y.endsWith('sam')) { \n    mate1fq = mate1_1.concat(\".fastq\")\n    mate2fq = mate2_1.concat(\".fastq\")\n  } else if (y.endsWith('fasta') || y.endsWith('fa') || y.endsWith('fasta.gz') || y.endsWith('fasta.bz2') || y.endsWith('fa.gz') || y.endsWith('fa.bz2')) {\n    mate1fq = mate1_1.concat(\".fasta\")\n    mate2fq = mate2_1.concat(\".fasta\")\n  }\n\n  \n  if ($job.inputs.sortUnmappedReads) {\n    \n  var cmd = \"\"\n  var sort_cmd = \" | sed 's/\\\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\\\t' '\\\\n' > \"\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    cmd = cmd.concat(\" && cat \", mate2, sort_cmd, mate2fq, \" && rm \", mate2)\n  }\n  if ($job.inputs.outReadsUnmapped == \"Fastx\") {\n    cmd = cmd.concat(\" && cat \", mate1, sort_cmd, mate1fq, \" && rm \", mate1)\n  }\n  return cmd\n  \n  } else {\n\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq, \" && mv \", mate2, \" \", mate2fq)\n  }\n  else if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length == 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq)\n  }\n\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var arr = [].concat($job.inputs.reads)\n\n  if ($job.inputs.sjdbFileChrStartEnd) {\n    twopass = \".twopass-multiple.\"\n  } else if ($job.inputs.twopassMode=='Basic') {\n    twopass = \".twopass-basic.\"\n  } else {\n    twopass = \".\"\n  }\n  \n  if ($job.inputs.outFileNamePrefix) {\n    var BAM = $job.inputs.outFileNamePrefix + twopass + 'Aligned.sortedByCoord.out.bam'\n    var transcript_BAM = $job.inputs.outFileNamePrefix + twopass + 'Aligned.toTranscriptome.out.bam'\n  } else if (arr[0].metadata && arr[0].metadata.sample_id) {\n    var BAM = arr[0].metadata.sample_id + twopass + 'Aligned.sortedByCoord.out.bam'\n    var transcript_BAM = arr[0].metadata.sample_id + twopass + 'Aligned.toTranscriptome.out.bam'\n  } else {\n    var BAM = arr[0].path.split('/').pop().split('.')[0] + twopass + 'Aligned.sortedByCoord.out.bam'\n    var transcript_BAM = arr[0].path.split('/').pop().split('.')[0] + twopass + 'Aligned.toTranscriptome.out.bam'\n  }\n  \n  \n  \n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  \n  if (SAM_type && SORT_type) {\n    if (SAM_type==\"SAM\") {\n      return \"\"\n    } else if (SORT_type==\"SortedByCoordinate\"){\n      return \"samtools index \" + BAM\n    } else {\n      return \"\"\n    }\n  } else if (SAM_type && SORT_type==null) {\n    return \"\"\n  } else {\n    if (SORT_type && SORT_type==\"SortedByCoordinate\") {\n      return \"samtools index \" + BAM\n    } else {\n      return \"\"\n    }\n  }\n  \n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ";",
            "position": 102
          }
        ],
        "sbg:contributors": [
          "uros_sipetic",
          "nemanja.vucic"
        ],
        "sbg:project": "uros_sipetic/star-2-5-4b-demo",
        "inputs": [
          {
            "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2, SAM, BAM",
            "label": "Read sequence",
            "sbg:category": "Basic",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n    function get_meta_map(m, file, meta) {\n        if (meta in file.metadata) {\n            return m[file.metadata[meta]]\n        } else {\n            return m['Undefined']\n        }\n    }\n\n    function create_new_map(map, file, meta) {\n        if (meta in file.metadata) {\n            map[file.metadata[meta]] = {}\n            return map[file.metadata[meta]]\n        } else {\n            map['Undefined'] = {}\n            return map['Undefined']\n        }\n    }\n\n\n  \n  \n  \n    arr = [].concat($job.inputs.reads)\n    ext = arr[0].path.split('.').pop().toLowerCase()\n    \n    // if bam input\n    if (ext=='bam' || ext=='sam') {\n      return \"--readFilesType SAM $str --readFilesIn \" + arr[0].path\n  \t}\n    \n    map = {}\n    \n    if (arr.length==1) {\n      return \"--readFilesIn \" + arr[0].path\n    }\n\n    for (i in arr) {\n\n        sm_map = get_meta_map(map, arr[i], 'sample_id')\n        if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id')\n\n        lb_map = get_meta_map(sm_map, arr[i], 'library_id')\n        if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id')\n\n        pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id')\n        if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id')\n\n        if ('file_segment_number' in arr[i].metadata) {\n            if (pu_map[arr[i].metadata['file_segment_number']]) {\n                a = pu_map[arr[i].metadata['file_segment_number']]\n                ar = [].concat(a)\n                ar = ar.concat(arr[i])\n                pu_map[arr[i].metadata['file_segment_number']] = ar\n            } else pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i])\n        } else {\n            if (pu_map['Undefined']) {\n                a = pu_map['Undefined']\n                ar = [].concat(a)\n                ar = ar.concat(arr[i])\n                pu_map['Undefined'] = ar\n            } else {\n                pu_map['Undefined'] = [].concat(arr[i])\n            }\n        }\n    }\n    tuple_list = []\n    for (sm in map)\n        for (lb in map[sm])\n            for (pu in map[sm][lb]) {\n                list = []\n                for (fsm in map[sm][lb][pu]) {\n                    list = map[sm][lb][pu][fsm]\n                \ttuple_list.push(list)\n                }\n            }\n  //return tuple_list[0]\n  \n  pe_1 = []\n  pe_2 = []\n  se = []\n  if (tuple_list[0].length==1) {\n    for (i=0; i<tuple_list.length; i++) {\n      se = se.concat(tuple_list[i][0].path)\n    }\n  }\n  //return se\n  for (i=0; i<tuple_list.length; i++) {\n    for (j=0; j<tuple_list[i].length; j++) {\n      if (tuple_list[i][j].metadata.paired_end==1) {\n        pe_1 = pe_1.concat(tuple_list[i][j].path)\n      } else if (tuple_list[i][j].metadata.paired_end==2) {\n        pe_2 = pe_2.concat(tuple_list[i][j].path)\n      }\n    }\n  }\n  \n  \n  \n    if (pe_2.length == 0) {\n        cmd = [];\n        if (se.length > 0) {\n            cmd = se\n        } else if (pe_1.length > 0) {\n            cmd = pe_1\n        }\n        return \"--readFilesIn \" + cmd.join(',')\n    } else if (pe_1.length > 0) {\n        cmd1 = [];\n        cmd2 = [];\n        for (i = 0; i < pe_1.length; i++) {\n            cmd1.push(pe_1[i])\n            cmd2.push(pe_2[i])\n        }\n        return \"--readFilesIn \" + cmd1.join(',') + \" \" + cmd2.join(',')\n    } else {\n        return \"\"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 10,
              "itemSeparator": " "
            },
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#reads",
            "description": "Read files, either in FASTQ or SAM/BAM formats."
          },
          {
            "label": "Reads lengths",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--readMatesLengthsIn"
            },
            "type": [
              "null",
              {
                "name": "readMatesLengthsIn",
                "symbols": [
                  "NotEqual",
                  "Equal"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "NotEqual",
            "id": "#readMatesLengthsIn",
            "description": "Equal/Not equal - lengths of names, sequences, qualities for both mates are the same/not the same. \"Not equal\" is safe in all situations."
          },
          {
            "label": "Reads to map",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--readMapNumber"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "id": "#readMapNumber",
            "description": "Number of reads to map from the beginning of the file."
          },
          {
            "label": "Junctions max number",
            "sbg:category": "Limits",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitOutSJoneRead"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1000",
            "id": "#limitOutSJoneRead",
            "description": "Max number of junctions for one read (including all multi-mappers)."
          },
          {
            "label": "Collapsed junctions max number",
            "sbg:category": "Limits",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitOutSJcollapsed"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1000000",
            "id": "#limitOutSJcollapsed",
            "description": "Max number of collapsed junctions."
          },
          {
            "label": "Output unmapped reads",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outReadsUnmapped"
            },
            "type": [
              "null",
              {
                "name": "outReadsUnmapped",
                "symbols": [
                  "None",
                  "Fastx"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outReadsUnmapped",
            "description": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2."
          },
          {
            "label": "Quality conversion",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outQSconversionAdd"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#outQSconversionAdd",
            "description": "Add this number to the quality score (e.g. to convert from Illumina to Sanger, use -31)."
          },
          {
            "label": "Output format",
            "sbg:category": "Output",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  if (SAM_type && SORT_type) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type)\n    }\n  } else if (SAM_type && SORT_type==null) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" Unsorted\")\n    }\n  } else {\n    if (SORT_type) {\n      return \"--outSAMtype \".concat(\"BAM\", \" \", SORT_type)\n    } else {\n      return \"--outSAMtype \".concat(\"BAM\", \" Unsorted\")\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              {
                "name": "outSAMtype",
                "symbols": [
                  "SAM",
                  "BAM"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "BAM",
            "id": "#outSAMtype",
            "description": "Format of output alignments."
          },
          {
            "label": "Output sorting type",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "outSortingType",
                "symbols": [
                  "Unsorted",
                  "SortedByCoordinate"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Unsorted",
            "id": "#outSortingType",
            "description": "Type of output sorting."
          },
          {
            "label": "SAM mode",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmode"
            },
            "type": [
              "null",
              {
                "name": "outSAMmode",
                "symbols": [
                  "Full",
                  "NoQS",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Full",
            "id": "#outSAMmode",
            "description": "Mode of SAM output. Full: full SAM output; NoQS: full SAM but without quality scores."
          },
          {
            "label": "Strand field flag",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMstrandField"
            },
            "type": [
              "null",
              {
                "name": "outSAMstrandField",
                "symbols": [
                  "None",
                  "intronMotif"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outSAMstrandField",
            "description": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out."
          },
          {
            "label": "SAM attributes",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMattributes"
            },
            "type": [
              "null",
              {
                "name": "outSAMattributes",
                "symbols": [
                  "Standard",
                  "NH",
                  "All",
                  "None",
                  "NH HI AS NM MD"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Standard",
            "id": "#outSAMattributes",
            "description": "Desired SAM attributes, in the order desired for the output SAM. NH: any combination in any order; Standard: NH HI AS nM; All: NH HI AS nM NM MD jM jI; None: no attributes."
          },
          {
            "label": "Write unmapped in SAM",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMunmapped"
            },
            "type": [
              "null",
              {
                "name": "outSAMunmapped",
                "symbols": [
                  "None",
                  "Within",
                  "Within KeepPairs"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outSAMunmapped",
            "description": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam)."
          },
          {
            "label": "Sorting in SAM",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMorder"
            },
            "type": [
              "null",
              {
                "name": "outSAMorder",
                "symbols": [
                  "Paired",
                  "PairedKeepInputOrder"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Paired",
            "id": "#outSAMorder",
            "description": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files."
          },
          {
            "label": "Primary alignments",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMprimaryFlag"
            },
            "type": [
              "null",
              {
                "name": "outSAMprimaryFlag",
                "symbols": [
                  "OneBestScore",
                  "AllBestScore"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "OneBestScore",
            "id": "#outSAMprimaryFlag",
            "description": "Which alignments are considered primary - all others will be marked with 0x100 bit in the FLAG. OneBestScore: only one alignment with the best score is primary; AllBestScore: all alignments with the best score are primary."
          },
          {
            "label": "Read ID",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMreadID"
            },
            "type": [
              "null",
              {
                "name": "outSAMreadID",
                "symbols": [
                  "Standard",
                  "Number"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Standard",
            "id": "#outSAMreadID",
            "description": "Read ID record type. Standard: first word (until space) from the FASTx read ID line, removing /1,/2 from the end; Number: read number (index) in the FASTx file."
          },
          {
            "label": "MAPQ value",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmapqUnique"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "255",
            "id": "#outSAMmapqUnique",
            "description": "MAPQ value for unique mappers (0 to 255)."
          },
          {
            "label": "OR SAM flag",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMflagOR"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#outSAMflagOR",
            "description": "Set specific bits of the SAM FLAG."
          },
          {
            "label": "AND SAM flag",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMflagAND"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "65535",
            "id": "#outSAMflagAND",
            "description": "Set specific bits of the SAM FLAG."
          },
          {
            "label": "SAM header @HD",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMheaderHD"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#outSAMheaderHD",
            "description": "@HD (header) line of the SAM header."
          },
          {
            "label": "SAM header @PG",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMheaderPG"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#outSAMheaderPG",
            "description": "Extra @PG (software) line of the SAM header (in addition to STAR)."
          },
          {
            "label": "Sequencing center",
            "sbg:category": "Read group",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_seq_center",
            "description": "Specify the sequencing center for RG line."
          },
          {
            "label": "Library ID",
            "sbg:category": "Read group",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_library_id",
            "description": "Specify the library ID for RG line."
          },
          {
            "label": "Median fragment length",
            "sbg:category": "Read group",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_mfl",
            "description": "Specify the median fragment length for RG line."
          },
          {
            "label": "Platform",
            "sbg:category": "Read group",
            "type": [
              "null",
              {
                "name": "rg_platform",
                "symbols": [
                  "LS 454",
                  "Helicos",
                  "Illumina",
                  "ABI SOLiD",
                  "Ion Torrent PGM",
                  "PacBio"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_platform",
            "description": "Specify the version of the technology that was used for sequencing or assaying."
          },
          {
            "label": "Platform unit ID",
            "sbg:category": "Read group",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_platform_unit_id",
            "description": "Specify the platform unit ID for RG line."
          },
          {
            "label": "Sample ID",
            "sbg:category": "Read group",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "#rg_sample_id",
            "description": "Specify the sample ID for RG line."
          },
          {
            "label": "Filtering type",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterType"
            },
            "type": [
              "null",
              {
                "name": "outFilterType",
                "symbols": [
                  "Normal",
                  "BySJout"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Normal",
            "id": "#outFilterType",
            "description": "Type of filtering. Normal: standard filtering using only current alignment; BySJout: keep only those reads that contain junctions that passed filtering into SJ.out.tab."
          },
          {
            "label": "Multimapping score range",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMultimapScoreRange"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1",
            "id": "#outFilterMultimapScoreRange",
            "description": "The score range below the maximum score for multimapping alignments."
          },
          {
            "label": "Max number of mappings",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10",
            "id": "#outFilterMultimapNmax",
            "description": "Read alignments will be output only if the read maps fewer than this value, otherwise no alignments will be output."
          },
          {
            "label": "Max number of mismatches",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10",
            "id": "#outFilterMismatchNmax",
            "description": "Alignment will be output only if it has fewer mismatches than this value."
          },
          {
            "label": "Mismatches to *mapped* length",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNoverLmax"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "0.3",
            "id": "#outFilterMismatchNoverLmax",
            "description": "Alignment will be output only if its ratio of mismatches to *mapped* length is less than this value."
          },
          {
            "label": "Mismatches to *read* length",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNoverReadLmax"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "1",
            "id": "#outFilterMismatchNoverReadLmax",
            "description": "Alignment will be output only if its ratio of mismatches to *read* length is less than this value."
          },
          {
            "label": "Min score",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterScoreMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#outFilterScoreMin",
            "description": "Alignment will be output only if its score is higher than this value."
          },
          {
            "label": "Min score normalized",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterScoreMinOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "0.66",
            "id": "#outFilterScoreMinOverLread",
            "description": "'Minimum score' normalized to read length (sum of mates' lengths for paired-end reads)."
          },
          {
            "label": "Min matched bases",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMatchNmin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#outFilterMatchNmin",
            "description": "Alignment will be output only if the number of matched bases is higher than this value."
          },
          {
            "label": "Min matched bases normalized",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMatchNminOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "0.66",
            "id": "#outFilterMatchNminOverLread",
            "description": "'Minimum matched bases' normalized to read length (sum of mates lengths for paired-end reads)."
          },
          {
            "label": "Motifs filtering",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterIntronMotifs"
            },
            "type": [
              "null",
              {
                "name": "outFilterIntronMotifs",
                "symbols": [
                  "None",
                  "RemoveNoncanonical",
                  "RemoveNoncanonicalUnannotated"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outFilterIntronMotifs",
            "description": "Filter alignment using their motifs. None: no filtering; RemoveNoncanonical: filter out alignments that contain non-canonical junctions; RemoveNoncanonicalUnannotated: filter out alignments that contain non-canonical unannotated junctions when using annotated splice junctions database. The annotated non-canonical junctions will be kept."
          },
          {
            "label": "Collapsed junctions reads",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterReads"
            },
            "type": [
              "null",
              {
                "name": "outSJfilterReads",
                "symbols": [
                  "All",
                  "Unique"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "All",
            "id": "#outSJfilterReads",
            "description": "Which reads to consider for collapsed splice junctions output. All: all reads, unique- and multi-mappers; Unique: uniquely mapping reads only."
          },
          {
            "label": "Min overhang SJ",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterOverhangMin",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "30 12 12 12",
            "id": "#outSJfilterOverhangMin",
            "description": "Minimum overhang length for splice junctions on both sides for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Does not apply to annotated junctions."
          },
          {
            "label": "Min unique count",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterCountUniqueMin",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "3 1 1 1",
            "id": "#outSJfilterCountUniqueMin",
            "description": "Minimum uniquely mapping read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions."
          },
          {
            "label": "Min total count",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterCountTotalMin",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "3 1 1 1",
            "id": "#outSJfilterCountTotalMin",
            "description": "Minimum total (multi-mapping+unique) read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions."
          },
          {
            "label": "Min distance to other donor/acceptor",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterDistToOtherSJmin",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "10 0 5 10",
            "id": "#outSJfilterDistToOtherSJmin",
            "description": "Minimum allowed distance to other junctions' donor/acceptor for each of the motifs (int >= 0). Does not apply to annotated junctions."
          },
          {
            "label": "Max gap allowed",
            "sbg:category": "Output filtering: splice junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterIntronMaxVsReadN",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "50000 100000 200000",
            "id": "#outSJfilterIntronMaxVsReadN",
            "description": "Maximum gap allowed for junctions supported by 1,2,3...N reads (int >= 0) i.e. by default junctions supported by 1 read can have gaps <=50000b, by 2 reads: <=100000b, by 3 reads: <=200000. By 4 or more reads: any gap <=alignIntronMax. Does not apply to annotated junctions."
          },
          {
            "label": "Gap open penalty",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGap"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#scoreGap",
            "description": "Gap open penalty."
          },
          {
            "label": "Non-canonical gap open",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapNoncan"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-8",
            "id": "#scoreGapNoncan",
            "description": "Non-canonical gap open penalty (in addition to --scoreGap)."
          },
          {
            "label": "GC/AG and CT/GC gap open",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapGCAG"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-4",
            "id": "#scoreGapGCAG",
            "description": "GC/AG and CT/GC gap open penalty (in addition to --scoreGap)."
          },
          {
            "label": "AT/AC and GT/AT gap open",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapATAC"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-8",
            "id": "#scoreGapATAC",
            "description": "AT/AC and GT/AT gap open penalty (in addition to --scoreGap)."
          },
          {
            "label": "Log scaled score",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGenomicLengthLog2scale"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "-0.25",
            "id": "#scoreGenomicLengthLog2scale",
            "description": "Extra score logarithmically scaled with genomic length of the alignment: <int>*log2(genomicLength)."
          },
          {
            "label": "Deletion open penalty",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreDelOpen"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-2",
            "id": "#scoreDelOpen",
            "description": "Deletion open penalty."
          },
          {
            "label": "Deletion extension penalty",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreDelBase"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-2",
            "id": "#scoreDelBase",
            "description": "Deletion extension penalty per base (in addition to --scoreDelOpen)."
          },
          {
            "label": "Insertion Open Penalty",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreInsOpen"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-2",
            "id": "#scoreInsOpen",
            "description": "Insertion open penalty."
          },
          {
            "label": "Insertion extension penalty",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreInsBase"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-2",
            "id": "#scoreInsBase",
            "description": "Insertion extension penalty per base (in addition to --scoreInsOpen)."
          },
          {
            "label": "Max score reduction",
            "sbg:category": "Scoring",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreStitchSJshift"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1",
            "id": "#scoreStitchSJshift",
            "description": "Maximum score reduction while searching for SJ boundaries in the stitching step."
          },
          {
            "label": "Search start point",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchStartLmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "50",
            "id": "#seedSearchStartLmax",
            "description": "Defines the search start point through the read - the read is split into pieces no longer than this value (int>0)."
          },
          {
            "label": "Search start point normalized",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchStartLmaxOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "1.0",
            "id": "#seedSearchStartLmaxOverLread",
            "description": "SeedSearchStartLmax normalized to read length (sum of mates' lengths for paired-end reads)."
          },
          {
            "label": "Max seed length",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchLmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#seedSearchLmax",
            "description": "Defines the maximum length of the seeds, if =0 max seed length is infinite (int>=0)."
          },
          {
            "label": "Filter pieces for stitching",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10000",
            "id": "#seedMultimapNmax",
            "description": "Only pieces that map fewer than this value are utilized in the stitching procedure (int>=0)."
          },
          {
            "label": "Max seeds per read",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedPerReadNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1000",
            "id": "#seedPerReadNmax",
            "description": "Max number of seeds per read (int>=0)."
          },
          {
            "label": "Max seeds per window",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedPerWindowNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "50",
            "id": "#seedPerWindowNmax",
            "description": "Max number of seeds per window (int>=0)."
          },
          {
            "label": "Max one-seed loci per window",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedNoneLociPerWindow"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10",
            "id": "#seedNoneLociPerWindow",
            "description": "Max number of one seed loci per window (int>=0)."
          },
          {
            "label": "Min intron size",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignIntronMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "21",
            "id": "#alignIntronMin",
            "description": "Minimum intron size: genomic gap is considered intron if its length >= alignIntronMin, otherwise it is considered Deletion (int>=0)."
          },
          {
            "label": "Max intron size",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignIntronMax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#alignIntronMax",
            "description": "Maximum intron size, if 0, max intron size will be determined by (2^winBinNbits)*winAnchorDistNbins."
          },
          {
            "label": "Max mates gap",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignMatesGapMax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#alignMatesGapMax",
            "description": "Maximum gap between two mates, if 0, max intron gap will be determined by (2^winBinNbits)*winAnchorDistNbins."
          },
          {
            "label": "Min overhang",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJoverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "5",
            "id": "#alignSJoverhangMin",
            "description": "Minimum overhang (i.e. block size) for spliced alignments (int>0)."
          },
          {
            "label": "Min overhang: annotated",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJDBoverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "3",
            "id": "#alignSJDBoverhangMin",
            "description": "Minimum overhang (i.e. block size) for annotated (sjdb) spliced alignments (int>0)."
          },
          {
            "label": "Min mapped length",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSplicedMateMapLmin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#alignSplicedMateMapLmin",
            "description": "Minimum mapped length for a read mate that is spliced (int>0)."
          },
          {
            "label": "Min mapped length normalized",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSplicedMateMapLminOverLmate"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "0.66",
            "id": "#alignSplicedMateMapLminOverLmate",
            "description": "AlignSplicedMateMapLmin normalized to mate length (float>0)."
          },
          {
            "label": "Max windows per read",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignWindowsPerReadNmax"
            },
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "10000",
            "id": "#alignWindowsPerReadNmax",
            "description": "Max number of windows per read (int>0)."
          },
          {
            "label": "Max transcripts per window",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignTranscriptsPerWindowNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "100",
            "id": "#alignTranscriptsPerWindowNmax",
            "description": "Max number of transcripts per window (int>0)."
          },
          {
            "label": "Max transcripts per read",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignTranscriptsPerReadNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10000",
            "id": "#alignTranscriptsPerReadNmax",
            "description": "Max number of different alignments per read to consider (int>0)."
          },
          {
            "label": "Alignment type",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignEndsType"
            },
            "type": [
              "null",
              {
                "name": "alignEndsType",
                "symbols": [
                  "Local",
                  "EndToEnd",
                  "Extend5pOfRead1",
                  "Extend3pOfRead1",
                  "Extend5pOfReads12"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Local",
            "id": "#alignEndsType",
            "description": "Type of read ends alignment. Local: standard local alignment with soft-clipping allowed. EndToEnd: force end to end read alignment, do not soft-clip; Extend5pOfRead1: fully extend only the 5p of the read1, all other ends: local alignment; Extend5pOfReads12: full extension of 5' ends of both mates."
          },
          {
            "label": "Soft clipping",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSoftClipAtReferenceEnds"
            },
            "type": [
              "null",
              {
                "name": "alignSoftClipAtReferenceEnds",
                "symbols": [
                  "Yes",
                  "No"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Yes",
            "id": "#alignSoftClipAtReferenceEnds",
            "description": "Option which allows soft clipping of alignments at the reference (chromosome) ends. Can be disabled for compatibility with Cufflinks/Cuffmerge. Yes: Enables soft clipping; No: Disables soft clipping."
          },
          {
            "label": "Max loci anchors",
            "sbg:category": "Windows, Anchors, Binning",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winAnchorMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "50",
            "id": "#winAnchorMultimapNmax",
            "description": "Max number of loci anchors are allowed to map to (int>0)."
          },
          {
            "label": "Bin size",
            "sbg:category": "Windows, Anchors, Binning",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winBinNbits"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "16",
            "id": "#winBinNbits",
            "description": "=log2(winBin), where winBin is the size of the bin for the windows/clustering, each window will occupy an integer number of bins (int>0)."
          },
          {
            "label": "Max bins between anchors",
            "sbg:category": "Windows, Anchors, Binning",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winAnchorDistNbins"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "9",
            "id": "#winAnchorDistNbins",
            "description": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0)."
          },
          {
            "label": "Flanking regions size",
            "sbg:category": "Windows, Anchors, Binning",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winFlankNbins"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "4",
            "id": "#winFlankNbins",
            "description": "=log2(winFlank), where win Flank is the size of the left and right flanking regions for each window (int>0)."
          },
          {
            "label": "Min segment length",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimSegmentMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#chimSegmentMin",
            "description": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0)."
          },
          {
            "label": "Min total score",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#chimScoreMin",
            "description": "Minimum total (summed) score of the chimeric segments (int>=0)."
          },
          {
            "label": "Max drop score",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreDropMax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "20",
            "id": "#chimScoreDropMax",
            "description": "Max drop (difference) of chimeric score (the sum of scores of all chimeric segements) from the read length (int>=0)."
          },
          {
            "label": "Min separation score",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreSeparation"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10",
            "id": "#chimScoreSeparation",
            "description": "Minimum difference (separation) between the best chimeric score and the next one (int>=0)."
          },
          {
            "label": "Non-GT/AG penalty",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreJunctionNonGTAG"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "id": "#chimScoreJunctionNonGTAG",
            "description": "Penalty for a non-GT/AG chimeric junction."
          },
          {
            "label": "Min junction overhang",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimJunctionOverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "20",
            "id": "#chimJunctionOverhangMin",
            "description": "Minimum overhang for a chimeric junction (int>=0)."
          },
          {
            "label": "Quantification mode",
            "sbg:category": "Quantification of Annotations",
            "type": [
              "null",
              {
                "name": "quantMode",
                "symbols": [
                  "TranscriptomeSAM",
                  "GeneCounts",
                  "TranscriptomeSAM GeneCounts"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#quantMode",
            "description": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping."
          },
          {
            "label": "Reads to process in 1st step",
            "sbg:category": "2-pass mapping",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "id": "#twopass1readsN",
            "description": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number (or default -1) to map all reads in the first step (int>0)."
          },
          {
            "label": "Two-pass mode",
            "sbg:category": "2-pass mapping",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--twopassMode"
            },
            "type": [
              "null",
              {
                "name": "twopassMode",
                "symbols": [
                  "None",
                  "Basic"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#twopassMode",
            "description": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly."
          },
          {
            "label": "Genome dir name",
            "sbg:category": "Basic",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  return $job.inputs.genomeDirName ? \"--genomeDir \" + $job.inputs.genomeDirName : \"--genomeDir genomeDir\" \n}\n\n",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 0
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "genomeDir",
            "id": "#genomeDirName",
            "description": "Name of the directory which contains genome files (when genome.tar is uncompressed)."
          },
          {
            "label": "Save junction files",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              {
                "name": "sjdbInsertSave",
                "symbols": [
                  "Basic",
                  "All",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#sjdbInsertSave",
            "description": "Which files to save when sjdb junctions are inserted on the fly at the mapping step. None: not saving files at all; Basic: only small junction/transcript files; All: all files including big Genome, SA and SAindex. These files are output as archive."
          },
          {
            "label": "Chromosome names",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#sjdbGTFchrPrefix",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes)."
          },
          {
            "label": "Set exons feature",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "exon",
            "id": "#sjdbGTFfeatureExon",
            "description": "Feature type in GTF file to be used as exons for building transcripts."
          },
          {
            "label": "Exons' parents name",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "transcript_id",
            "id": "#sjdbGTFtagExonParentTranscript",
            "description": "Tag name to be used as exons transcript-parents."
          },
          {
            "label": "Gene name",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "gene_id",
            "id": "#sjdbGTFtagExonParentGene",
            "description": "Tag name to be used as exons gene-parents."
          },
          {
            "label": "\"Overhang\" length",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "100",
            "id": "#sjdbOverhang",
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used."
          },
          {
            "label": "Extra alignment score",
            "sbg:category": "Splice junctions database",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "2",
            "id": "#sjdbScore",
            "description": "Extra alignment score for alignments that cross database junctions."
          },
          {
            "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
            "label": "Splice junction file",
            "sbg:category": "Basic",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbGTFfile",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#sjdbGTFfile",
            "description": "Gene model annotations and/or known transcripts. No need to include this input, except in case of using \"on the fly\" annotations. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\"."
          },
          {
            "label": "Clip 3p bases",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--clip3pNbases",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#clip3pNbases",
            "description": "Number of bases to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates."
          },
          {
            "label": "Clip 5p bases",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--clip5pNbases",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#clip5pNbases",
            "description": "Number of bases to clip from 5p of each mate. In case only one value is given, it will be assumed the same for both mates."
          },
          {
            "label": "Clip 3p adapter sequence",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--clip3pAdapterSeq",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "string",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#clip3pAdapterSeq",
            "description": "Adapter sequence to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates."
          },
          {
            "label": "Max mismatches proportions",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--clip3pAdapterMMp",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "float",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "0.1",
            "id": "#clip3pAdapterMMp",
            "description": "Max proportion of mismatches for 3p adapter clipping for each mate. In case only one value is given, it will be assumed the same for both mates."
          },
          {
            "label": "Clip 3p after adapter seq",
            "sbg:category": "Read parameters",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--clip3pAfterAdapterNbases",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "name": "clip3pAfterAdapterNbases",
                "items": "int",
                "type": "array"
              }
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#clip3pAfterAdapterNbases",
            "description": "Number of bases to clip from 3p of each mate after the adapter clipping. In case only one value is given, it will be assumed the same for both mates."
          },
          {
            "label": "Chimeric output type",
            "sbg:category": "Chimeric Alignments",
            "type": [
              "null",
              {
                "name": "chimOutType",
                "symbols": [
                  "SeparateSAMold",
                  "Within SoftClip",
                  "Within HardClip"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "SeparateSAMold",
            "id": "#chimOutType",
            "description": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; Within: output into main aligned SAM/BAM files (can be hard-clipping or soft-clipping in the CIGAR for supplemental chimeric alignments)."
          },
          {
            "sbg:fileTypes": "TAR",
            "label": "Genome files",
            "sbg:category": "Basic",
            "type": [
              "File"
            ],
            "id": "#genome",
            "description": "Genome files created using STAR Genome Generate."
          },
          {
            "label": "Max insert junctions",
            "sbg:category": "Limits",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitSjdbInsertNsj"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1000000",
            "id": "#limitSjdbInsertNsj",
            "description": "Maximum number of junction to be inserted to the genome on the fly at the mapping stage, including those from annotations and those detected in the 1st step of the 2-pass run."
          },
          {
            "label": "Prohibit alignment type",
            "sbg:category": "Quantification of Annotations",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--quantTranscriptomeBan"
            },
            "type": [
              "null",
              {
                "name": "quantTranscriptomeBan",
                "symbols": [
                  "IndelSoftclipSingleend",
                  "Singleend"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "IndelSoftclipSingleend",
            "id": "#quantTranscriptomeBan",
            "description": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments."
          },
          {
            "label": "Limit BAM sorting memory",
            "sbg:category": "Limits",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  return $job.inputs.limitBAMsortRAM ? $job.inputs.limitBAMsortRAM : 57000000000\n}\n",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitBAMsortRAM"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "57000000000",
            "id": "#limitBAMsortRAM",
            "description": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size."
          },
          {
            "label": "Max number of multiple alignment",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmultNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "id": "#outSAMmultNmax",
            "description": "Max number of multiple alignments for a read that will be output to the SAM/BAM files."
          },
          {
            "label": "Order of multimapping alignment",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outMultimapperOrder"
            },
            "type": [
              "null",
              {
                "name": "outMultimapperOrder",
                "symbols": [
                  "Random",
                  "Old_2.4"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Old_2.4",
            "id": "#outMultimapperOrder",
            "description": "Random option outputs multiple alignments for each read in random order, and also also randomizes the choice of the primary alignment from the highest scoring alignments."
          },
          {
            "label": "IH attribute start value",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMattrIHstart"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "1",
            "id": "#outSAMattrIHstart",
            "description": "Start value for the IH attribute. 0 may be required by some downstream software, such as Cufflinks or StringTie."
          },
          {
            "label": "Output filter",
            "sbg:category": "Output",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMfilter"
            },
            "type": [
              "null",
              {
                "name": "outSAMfilter",
                "symbols": [
                  "KeepOnlyAddedReferences",
                  "None",
                  "KeepAllAddedReferences"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outSAMfilter",
            "description": "Filter the output into main SAM/BAM files."
          },
          {
            "label": "Splice junction stich max mismatch",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJstitchMismatchNmax"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0 -1 0 0",
            "id": "#alignSJstitchMismatchNmax",
            "description": "4*int>=0: maximum number of mismatches for stitching of the splice junctions (-1: no limit). (1) non-canonical motifs, (2) GT/AG and CT/AC motif, (3) GC/AG and CT/GC motif, (4) AT/AC and GT/AT motif."
          },
          {
            "label": "Chimeric segment gap",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimSegmentReadGapMax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#chimSegmentReadGapMax",
            "description": "Maximum gap in the read sequence between chimeric segments (int>=0)."
          },
          {
            "label": "Chimeric filter",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimFilter"
            },
            "type": [
              "null",
              {
                "name": "chimFilter",
                "symbols": [
                  "banGenomicN",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "banGenomicN",
            "id": "#chimFilter",
            "description": "Different filters for chimeric alignments None no filtering banGenomicN Ns are not allowed in the genome sequence around the chimeric junction."
          },
          {
            "label": "Unmapped output file names",
            "sbg:category": "Output",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "\"Unmapped.out\"",
            "id": "#unmappedOutputName",
            "description": "Names of the unmapped output files."
          },
          {
            "label": "No read groups",
            "sbg:category": "Read group",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:toolDefaultValue": "Off",
            "id": "#no_read_groups",
            "description": "If this boolean argument is specified, no read groups will be set in the resulting BAM header."
          },
          {
            "label": "Sort unmapped reads",
            "sbg:category": "Output",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:toolDefaultValue": "Off",
            "id": "#sortUnmappedReads",
            "description": "Unmapped reads are, by default, unsorted. If you want to sort them by read ID, please specify this option, though keep in mind that this can increase STAR run time."
          },
          {
            "sbg:fileTypes": "TXT,SJDB,TAB",
            "label": "List of annotated junctions",
            "sbg:category": "Basic",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--sjdbFileChrStartEnd",
              "itemSeparator": " "
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#sjdbFileChrStartEnd",
            "description": "List of splice junction coordinates in a tab-separated file."
          },
          {
            "label": "Number of threads",
            "sbg:category": "Run parameters",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "32",
            "id": "#runThreadN",
            "description": "Number of threads to use."
          },
          {
            "label": "Protrusion of alignment ends",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignEndsProtrude"
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0 ConcordantPair",
            "id": "#alignEndsProtrude",
            "description": "Allow protrusion of alignment ends, i.e. start (end) of the +strand mate downstream of the start (end) of the -strand mate. The input should two arguments separated by a space: the first is the maximum number of protrusion bases allowed, and the second is [Concordantpair or DiscordantPair], telling whether to report alignments with non-zero protrusion as concordant/discordant pairs."
          },
          {
            "label": "Max main chimeric segment alignments",
            "sbg:category": "Chimeric Alignments",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimMainSegmentMultNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "10",
            "id": "#chimMainSegmentMultNmax",
            "description": "Maximum number of multi-alignments for the main chimeric segment. The value of 1 will prohibit multimapping main segments.",
            "sbg:stageInput": null
          },
          {
            "label": "Output file name prefix",
            "sbg:category": "Output",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "sample_id",
            "id": "#outFileNamePrefix",
            "description": "Prefix to be added to all output files."
          },
          {
            "label": "BAM remove duplicates type",
            "sbg:category": "BAM processing",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var x = $job.inputs.reads\n  if (x.length==2 && $job.inputs.bamRemoveDuplicatesType) {\n    return \"--bamRemoveDuplicatesType \" + $job.inputs.bamRemoveDuplicatesType\n  } else {\n    return \"\"\n  }\n  \n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              {
                "name": "bamRemoveDuplicatesType",
                "symbols": [
                  "UniqueIdentical",
                  "UniqueIdenticalNotMulti"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Off",
            "id": "#bamRemoveDuplicatesType",
            "description": "Mark duplicates in the BAM file. For now, only works with paired-end alignments. UniqueIdentical: mark all mutlimappers and duplicate unique mappers. The coordinates, FLAG, CIGAR must be identical. UniqueIdenticalNotMulti: mark duplicate unique mappers but not multimappers."
          },
          {
            "label": "BAM remove duplicates mate2 bases",
            "sbg:category": "BAM processing",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var x = $job.inputs.reads\n  if (x.length==2 && $job.inputs.bamRemoveDuplicatesMate2basesN && $job.inputs.bamRemoveDuplicatesType) {\n    return \"--bamRemoveDuplicatesMate2basesN \" + $job.inputs.bamRemoveDuplicatesMate2basesN\n  } else {\n    return \"\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "0",
            "id": "#bamRemoveDuplicatesMate2basesN",
            "description": "Number of bases from the 5' end of mate 2 to use in collapsing (e.g. for RAMPAGE)."
          },
          {
            "label": "Output wiggle type",
            "sbg:category": "Output Wiggle",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outWigType"
            },
            "type": [
              "null",
              {
                "name": "outWigType",
                "symbols": [
                  "bedGraph",
                  "bedGraph read1_5p",
                  "bedGraph read2",
                  "wiggle",
                  "wiggle read1_5p",
                  "wiggle read2"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "#outWigType",
            "description": "Type of wiggle signal output. Options are bedGraph and wiggle, with the second word indicating whether to include signal only from 5' of the 1st read (useful for CAGE/RAMPAGE etc) or only from the 2nd read, respectively."
          },
          {
            "label": "Output wiggle strand",
            "sbg:category": "Output Wiggle",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.outWigType && $job.inputs.outWigStrand) {\n    return \"--outWigStrand \" + $job.inputs.outWigStrand\n  } else {\n    return \"\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              {
                "name": "outWigStrand",
                "symbols": [
                  "Stranded",
                  "Unstranded"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Stranded",
            "id": "#outWigStrand",
            "description": "Strandedness of wiggle/bedGraph output. Stranded - separate strands, str1 and str2; Unstranded - collapsed strands."
          },
          {
            "label": "Output wiggle reference prefix",
            "sbg:category": "Output Wiggle",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.outWigType && $job.inputs.outWigReferencePrefix) {\n    return \"--outWigReferencePrefix \" + $job.inputs.outWigReferencePrefix\n  } else {\n    return \"\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "id": "#outWigReferencePrefix",
            "description": "Prefix matching reference names to include in the output wiggle file, e.g. \"chr\". Default is \"-\", to include all references."
          },
          {
            "label": "Output wiggle normalization",
            "sbg:category": "Output Wiggle",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.outWigType && $job.inputs.outWigNorm) {\n    return \"--outWigNorm \" + $job.inputs.outWigReferencePrefix\n  } else {\n    return \"\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              {
                "name": "outWigNorm",
                "symbols": [
                  "None",
                  "RPM"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "RPM",
            "id": "#outWigNorm",
            "description": "Type of normalization for the output wiggle signal. RPM - reads per million of mapped reads; None - no normalization, \"raw\" counts."
          },
          {
            "label": "Filter intron strands",
            "sbg:category": "Output filtering",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterIntronStrands"
            },
            "type": [
              "null",
              {
                "name": "outFilterIntronStrands",
                "symbols": [
                  "RemoveInconsistentStrands",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "RemoveInconsistentStrands",
            "id": "#outFilterIntronStrands",
            "description": "Remove alignments that have junctions with inconsistent strands. On by default.",
            "sbg:stageInput": null
          },
          {
            "label": "Seed split min",
            "sbg:category": "Alignments and Seeding",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSplitMin"
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "12",
            "id": "#seedSplitMin",
            "description": "Minimum length of the seed sequences split by Ns or mate gap. Changing this parameters to a value lower than the default (12), allows mapping of mates shorter than 12 base pairs.",
            "sbg:stageInput": null
          }
        ],
        "sbg:revision": 7,
        "sbg:content_hash": "a09ba9de5f35278185eb7463822f4374849c0f32b7c2e4aa0ed845e3cbe57b535",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "id": "https://api.sbgenomics.com/v2/apps/uros_sipetic/star-2-5-4b-demo/star-2-5-4b/7/raw/",
        "description": "**STAR** is an ultrafast universal RNA-seq aligner. \n\n**STAR** (Spliced Transcripts Alignment to a Reference), an ultrafast RNA-seq aligner, is capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. **STAR** employs an RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs [1].\n\n**STAR** works with reads starting from lengths ~15 bases up to ~300 bases. In case of having longer reads, the use of **STAR Long** tool is recommended instead.\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\nThe main purpose of **STAR** is to generate aligned BAM files (in genome and transcriptome coordinates) from RNA-seq data, which can later be used in further RNA studies, like gene expression analysis for example. \n\nSome important notes about this tool are: \n\n- The main input to the tool are **Reads** (`--readFilesIn`) in FASTQ format (single end or paired end), or unaligned BAM format.\n- **Genome files** in the form of a **STAR index archive**, outputted by the **STAR Genome Generate** tool, also need to be provided.\n- It\u2019s generally a good idea to always provide a GTF file to the inputs, if you want to get the **Transcriptome aligned reads** and **Reads per gene** outputs. \n- The main output of this tool is the **Aligned reads** output in coordinate sorted BAM format. The **Transcriptome aligned reads** BAM file is produced if the **Quantification mode** (`--quantMode`) parameter is set to **TranscriptomeSAM**. \n- Gene counts are produced if the **Quantification mode** (`--quantMode`) parameter is set to **GeneCounts**.  \n- **STAR** can detect chimeric transcripts, but the parameter **Min segment length** (`--chimSegmentMin`) in *Chimeric Alignments*  category must be adjusted to a desired minimum chimeric segment length (12 is a good value, as recommended by the **STAR-Fusion** wiki). This output can later be used in **STAR-Fusion** for further fusion analysis. \n- If you want to use **STAR** results as an input to an RNA-seq differential expression analysis(using the **Cufflinks** app), set the parameter **Strand field flag** (`--outSAMstrandField`) to **intronMotif**.\n- Unmapped reads in FASTQ format are outputted on the **Unmapped reads** output if the **Output unmapped reads** (`--outReadsUnmapped`) parameter is set to the **Fastx** value. \n- Unmapped reads can be outputted within the main out BAM file on the **Aligned reads** and **Transcriptome aligned reads** outputs if the **Write unmapped in SAM** (`--outSAMunmapped`) parameter is set to **Within** or **Within KeepPairs**. \n- A basic **Two-pass mode** can be turned during the alignment step, which means that all the first pass junctions will be inserted into the genome indices for the second pass, by setting the **Two-pass mode** (`--twopassMode`) option to **Basic**. \n\n###Common issues###\n- For paired-end read files, it is important to properly set the **Paired-end** metadata field on your read files.\n- For FASTQ reads in multi-file format (i.e. two FASTQ files for paired-end 1 and two FASTQ files for paired-end2), the proper metadata needs to be set (the following hierarchy is valid: **Sample ID/Library ID/Platform Unit ID/File Segment Number**).\n\n### Changes Introduced by Seven Bridges\n\n- All output files will be prefixed by the input sample ID (inferred from the **Sample ID** metadata if existent, of from filename otherwise), unless the **Output file name prefix** option is explicitly specified.\n- **Unmapped reads** in FASTQ format are by default unsorted by read ID. This can induce problems if these files are used in subsequent analysis (i.e. downstream alignment). The option to sort unmapped reads by read ID is added to this wrapper, by setting the **Sort unmapped reads** parameter to True. The suffix for the **Unmapped reads** output can be controlled by the **Unmapped output file names** options (the default is *Unmapped*).\n- The tool can accept uncompressed FASTQ files, as well as GZ and BZ2 compressed FASTQ files, without the user having to specify anything. Also, if unaligned BAM files are used as inputs, the single-end/paired-end flag (SE/PE) needn't be specified - it will inferred automatically using a built-in **Samtools** script. \n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs for a couple of samples with different file sizes, with the following options in mind - unmapped reads are sorted by read id, output BAM is sorted by coordinate and basic two pass mode is turned on:\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost |  Instance (AWS) |\n|:---------------:|:-----------:|:----------:|:----------:|:-----------:|:--------:|:-----:|:----------:|\n|     RNA-Seq     |  2 x 230 MB |     Yes    |     1M     |     101     |   18min   | $0.40 | c4.8xlarge |\n|     RNA-Seq     |  2 x 4.5 GB |     Yes    |     20M     |     101     |   30min   | $0.60 | c4.8xlarge |\n|     RNA-Seq     | 2 x 17.4 GB |     Yes    |     76M    |     101     |   64min  | $1.20 | c4.8xlarge |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n\n[1] [STAR paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)",
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:toolkit": "STAR",
        "sbg:toolkitVersion": "2.5.4b",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "label": "STAR",
        "sbg:categories": [
          "Alignment",
          "RNA"
        ],
        "cwlVersion": "sbg:draft-2",
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  if ($job.inputs.reads) {\n    \n    var list = [].concat($job.inputs.reads)\n    var ext = list[0].path.split('.').pop().toLowerCase()\n  \n    if (ext=='bam' || ext=='sam') {\n      bam_file = list[0].path\n      cmd_line = \"str='SE' && count=`samtools view -h \" + bam_file + \" | head -n 500000 | samtools view -c -f 0x1 -`\";\n      cmd_line = cmd_line + \" && if [ $count != 0 ]; then str='PE'; fi;\"\n      return cmd_line\n    } else {\n      return \"\"\n    }\n  }\n}\n",
            "engine": "#cwl-js-engine"
          },
          {
            "class": "Expression",
            "script": "{\n  var cpus = $job.inputs.runThreadN ? $job.inputs.runThreadN : 32\n  return \"tar -xvf \" + $job.inputs.genome.path + \" && STAR --runThreadN \" + cpus\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:id": "admin/sbg-public-data/star-2-5-4b/7",
        "sbg:modifiedOn": 1551092161,
        "class": "CommandLineTool",
        "stdin": ""
      },
      "id": "#STAR",
      "sbg:y": 320.01474439246863
    }
  ],
  "class": "Workflow",
  "sbg:links": [
    {
      "id": "https://github.com/alexdobin/STAR",
      "label": "Homepage"
    },
    {
      "id": "https://github.com/alexdobin/STAR",
      "label": "Source Code"
    },
    {
      "id": "https://github.com/alexdobin/STAR/archive/2.5.4b.tar.gz",
      "label": "Download"
    },
    {
      "id": "https://groups.google.com/forum/#!forum/rna-star",
      "label": "Publication"
    },
    {
      "id": "http://www.ncbi.nlm.nih.gov/pubmed/23104886",
      "label": "Documentation"
    }
  ],
  "sbg:toolkit": "STAR",
  "sbg:toolkitVersion": "2.5.4b",
  "requirements": [],
  "sbg:toolAuthor": "Seven Bridges",
  "sbg:projectName": "SBG Public Data",
  "cwlVersion": "sbg:draft-2",
  "sbg:canvas_zoom": 0.5999999999999996,
  "sbg:appVersion": [
    "sbg:draft-2"
  ],
  "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/rna-seq-alignment-star-2-5-4b/19/raw/",
  "sbg:id": "admin/sbg-public-data/rna-seq-alignment-star-2-5-4b/19",
  "sbg:revision": 19,
  "sbg:revisionNotes": "Changes made to reads JS expression in order to handle multiple samples on input.",
  "sbg:modifiedOn": 1551106985,
  "sbg:modifiedBy": "admin",
  "sbg:createdOn": 1522949980,
  "sbg:createdBy": "admin",
  "sbg:project": "admin/sbg-public-data",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "admin"
  ],
  "sbg:latestRevision": 19,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "a8d0259afde24d3aeaa7572ed09a83a1450a8739afe8c675d3bf6858600b42d3e"
}